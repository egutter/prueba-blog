<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 10 Pines Blog</title>
    <link>http://blog.10pines.com/categories/java/</link>
    <description>Recent content in Java on 10 Pines Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 May 2015 17:15:00 +0000</lastBuildDate>
    <atom:link href="http://blog.10pines.com/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java Interface Default Methods. What?</title>
      <link>http://blog.10pines.com/2015/05/19/java-interface-default-methods/</link>
      <pubDate>Tue, 19 May 2015 17:15:00 +0000</pubDate>
      
      <guid>http://blog.10pines.com/2015/05/19/java-interface-default-methods/</guid>
      <description>

&lt;p&gt;In my last post I&amp;rsquo;ve presented both traits and mixins, with the promise of identifying the Java 8 Interface Default Methods. So, let&amp;rsquo;s get on it.&lt;/p&gt;

&lt;p&gt;First of all, if you don’t know what I’m talking about, &lt;a href=&#34;http://blog.10pines.com/2014/10/14/mixins-or-traits/&#34;&gt;read my previous post&lt;/a&gt; -and &lt;em&gt;please&lt;/em&gt; ignore the fact that it took me almost half a year to write this second part :)&lt;/p&gt;

&lt;p&gt;A quick summary:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixins:&lt;/strong&gt; Abstract subclasses. You can call &lt;code&gt;super&lt;/code&gt; from inside the mixin, and can define both methods and variables. Mixins automatically solves conflict by linearization (inserting the mixin in the method lookup chain from left to right).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Traits:&lt;/strong&gt; Allow us to define behaviour outside the class, but don&amp;rsquo;t define state. The methods defined in the trait «have the same semantics» as the method defined in the class (Flattening property). It’s like they were copied into the class. You have to handle conflicts by yourself.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can fully dive into Java Interface default methods.&lt;/p&gt;

&lt;h1 id=&#34;how-do-we-define-a-default-method-whatever-that-is&#34;&gt;How do we define a default method (whatever that is)?&lt;/h1&gt;

&lt;p&gt;Easy peasy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public interface InterfaceA {
	public default String m1() { return &amp;quot;This is InterfaceA.m1&amp;quot;; }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference with a Class method is the little keyword &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, assuming we have a class like the following&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class SomeClass implements InterfaceA { }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we call &lt;code&gt;new SomeClass().m1()&lt;/code&gt; the evaluation sysout is &lt;code&gt;This is InterfaceA.m1&lt;/code&gt;. As I said, easy peasy.&lt;/p&gt;

&lt;h1 id=&#34;aaaaaand-what-about-multiple-inheritance&#34;&gt;Aaaaaand&amp;hellip; what about multiple inheritance?&lt;/h1&gt;

&lt;p&gt;Both traits and mixins allow us some kind of multiple inheritance. I&amp;rsquo;m trying to define default methods as some of the two, so is logical to expect this particular behavior in java 8 too.&lt;/p&gt;

&lt;p&gt;Well, you are right. The way to do it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public interface InterfaceB {
	public default String m1() { return &amp;quot; This is InterfaceB.m1&amp;quot;; }
}

public class SomeClass implements InterfaceA, InterfaceB { }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we have our multiple inheritance&amp;hellip; or not?&lt;/p&gt;

&lt;h2 id=&#34;conflict-solving&#34;&gt;Conflict Solving&lt;/h2&gt;

&lt;p&gt;There are three rules to consider in the method lookup while dealing with default methods:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Classes win over interfaces.&lt;/strong&gt;  If a class in the superclass chain has a declaration for the method (concrete or abstract), you&amp;rsquo;re done, and defaults are irrelevant.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;More specific interfaces win over less specific ones&lt;/strong&gt;* (where specificity means &amp;ldquo;subtyping&amp;rdquo;).  A default from List wins over a default from Collection, regardless of where or how or how many times List and Collection enter the inheritance graph.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;There is no Rule #3.&lt;/strong&gt; If there is not a unique winner according to the above rules, concrete classes must disambiguate manually.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And, because of Rule #3:&lt;/p&gt;

&lt;p&gt;{% img /images/compile-error.png %}&lt;/p&gt;

&lt;p&gt;So, we need to solve the conflicts ourselves. Let&amp;rsquo;s clean up our own mess:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class SomeClass implements InterfaceA, InterfaceB {
	@Override
	public String m1() {
		return InterfaceA.super.m1() + InterfaceB.super.m1();
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, it&amp;rsquo;s not the prettiest solution, but it&amp;rsquo;s definitely easy to understand what&amp;rsquo;s happening there: I&amp;rsquo;m calling first to &lt;code&gt;InterfaceA.m1()&lt;/code&gt; and then &lt;code&gt;InterfaceB.m1()&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;With this override, if we reevaluate &lt;code&gt;new SomeClass().m1()&lt;/code&gt; we get &lt;code&gt;This is InterfaceA.m1 This is InterfaceB.m1&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;so-what-it-is&#34;&gt;So? What it is?&lt;/h1&gt;

&lt;p&gt;There are two big things to take into consideration for defining (or deciding) between one or the other:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Default methods are defined in &lt;em&gt;interfaces&lt;/em&gt;. As we know, we cannot declare variables in interfaces - there are just method declarations (and now, definitions); and&lt;/li&gt;
&lt;li&gt;We don&amp;rsquo;t have an automatic method for conflict solving (i.e. linearization), we have to decide &lt;em&gt;manually&lt;/em&gt; how we are going to call our methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this things in mind, I&amp;rsquo;m inclined to say that &lt;strong&gt;Interface default methods &lt;em&gt;are&lt;/em&gt; traits&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Mixins can have state and solve multiple inheritance problems with linearization, while traits can’t&amp;rsquo; define variables and they let you deal with conflict solving.&lt;/p&gt;

&lt;p&gt;Yes, Pharo&amp;rsquo;s traits had more ways to solve conflicts, but I don&amp;rsquo;t think that is enough to discard default methods as traits.&lt;/p&gt;

&lt;p&gt;They are no perfect traits, but as a mostly-java developer, I&amp;rsquo;m already used to that :)&lt;/p&gt;

&lt;h2 id=&#34;wait-you-are-forgetting-the-flattening-property&#34;&gt;Wait, you are forgetting the flattening property&lt;/h2&gt;

&lt;p&gt;Well&amp;hellip; I don&amp;rsquo;t &lt;em&gt;really&lt;/em&gt; know about this.&lt;/p&gt;

&lt;p&gt;I know the object understand &lt;code&gt;m1()&lt;/code&gt;. And I can distinguish between default and non-default methods&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:if-that-is-useful-for-something&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:if-that-is-useful-for-something&#34;&gt;0&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;What I cannot know is if the method is actually &amp;ldquo;flattenizing&amp;rdquo; (it&amp;rsquo;s that even a word?) into the class. Nor I know a way to demonstrate it. So I decided it&amp;rsquo;s easier to ignore that issue :)&lt;/p&gt;

&lt;p&gt;I think that flattening it&amp;rsquo;s not the core of traits, it&amp;rsquo;s just an implementation issue and a nice feature for analyze in academical environments. IMHO the real value comes from conflict solving and variables - or in this case, the absence of them.&lt;/p&gt;

&lt;h1 id=&#34;some-thoughts-i-came-up-with-during-this-process&#34;&gt;Some thoughts I came up with during this process&lt;/h1&gt;

&lt;p&gt;It is not particulary necessary to classify default methods. I see them closer to traits than to mixins. Some can disagree. Some others can have a different understanding about traits/mixins. The thing is, &lt;em&gt;there&amp;rsquo;s no real reason for making this distinction&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I did it just because I find things like these entertaining, not practical. In the end (i.e. day-to-day work) I call&amp;rsquo;em default methods, just like the rest of my teammates.&lt;/p&gt;

&lt;p&gt;Another fun (and maybe practical) thing to do is find the best practices with these things. Default Methods are another tool we have in our hands, so let&amp;rsquo;s try to get the best of&amp;rsquo;em while we build &lt;em&gt;good software.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;ve just getting into this path, so let&amp;rsquo;s talk about that some other time :)&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;It does looks &lt;a href=&#34;http://blog.10pines.com/2014/10/14/mixins-or-traits/#fn:2&#34;&gt;suspiciously similar to Scala&lt;/a&gt;, doesn&amp;rsquo;t it?
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Java generics and inheritance (part 2)</title>
      <link>http://blog.10pines.com/2014/12/02/java-generics-and-inheritance-part-2/</link>
      <pubDate>Tue, 02 Dec 2014 17:10:14 +0000</pubDate>
      
      <guid>http://blog.10pines.com/2014/12/02/java-generics-and-inheritance-part-2/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://blog.10pines.com/2014/12/02/java-generics-and-inheritance-part-1&#34;&gt;On the first part of this article&lt;/a&gt; I explained why java generics don&amp;rsquo;t allow up-casting for generified types.
In this part we will see why, arrays don&amp;rsquo;t have that restriction, and the implications for &lt;em&gt;reflection&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;but-arrays&#34;&gt;But arrays&amp;hellip;&lt;/h2&gt;

&lt;p&gt;If generified lists aren&amp;rsquo;t allowed to up-cast, why arrays are?&lt;br /&gt;
The reason is very simple: arrays don&amp;rsquo;t erase their element type. At runtime, each array knows exactly which kind of element it should allow in. If you try this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
String[] stringArray = new String[1];
Object[] objectArray = stringArray; // Perfectly normal

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler allows you to up-cast. What if we try to put something in the string array, that is not a string?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
objectArray[0] = 1; //1 is not a String -&amp;gt; ArrayStoreException

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yep, the array reacts to your wrong doing and it throws you an ArrayStoreException if you try to put anything that is not a String (or subtype). The array retains its complete type information in runtime.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.10pines.com/images/2014-12-02-java-generics-and-inheritance-part-2-VennArrayObjectArrayString.jpg&#34; alt=&#34;Venn diagram of arrays&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So basically, while you can see an array as an instance of a super type, the array doesn&amp;rsquo;t lose its type. The type of an array is not lost at runtime because it&amp;rsquo;s reified (there&amp;rsquo;s an object that represents it at runtime). It doesn&amp;rsquo;t depend on the type of the variable it&amp;rsquo;s assigned to.
On the other hand, a list type does depend on the variable it&amp;rsquo;s assigned to, and that&amp;rsquo;s why you cannot up-cast generic types, so you don&amp;rsquo;t change the type of contained elements. As lists don&amp;rsquo;t reify their element type you could put whatever inside, and then the implicit casts of generics may break.&lt;/p&gt;

&lt;h2 id=&#34;not-everything-is-erased&#34;&gt;Not everything is erased&lt;/h2&gt;

&lt;p&gt;Would all this be fixed if we retained the element type of List, as arrays do?&lt;br /&gt;
If we could do that, then we could be consistent about the list type, no matter what. And we could check that the list contains elements of a single type.
In other words if we retained the type argument of a generified type in runtime, using reflection we could reject wrong elements.&lt;br /&gt;
I dare say that if the type arguments were reified with the parameterized type and made available to the created instance, none of the counter-intuitive generics restrictions would be needed. Assigning a string list to an object list variable would be as natural as doing so for arrays.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bad news&lt;/strong&gt; is that instantiating a generic class with a type argument like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
new ArrayList&amp;lt;String&amp;gt;()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Will not preserve its type argument at runtime, and there seems to be no interest in doing so.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Good news&lt;/strong&gt; is that extending a generic class with a type argument like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class MyStringList extends ArrayList&amp;lt;String&amp;gt;{
  List&amp;lt;Object&amp;gt; castToObjectList(){return (List)this;}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does retain the type argument in runtime. So using reflection to check for valid additions to the list is possible and also this kind of code is compile time safe:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
MyStringList stringList = new MyStringList();
List&amp;lt;Object&amp;gt; objectList = stringList.castToObjectList(); // no error
objectList.add(1);   // Proper error if not a string

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;multiple-ways-of-getting-the-supertype&#34;&gt;Multiple ways of getting the supertype&lt;/h2&gt;

&lt;p&gt;So far this has been an introduction to finally talk about reflection and generics.&lt;br /&gt;
We declared a class that parametrizes a List:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class MyStringList extends ArrayList&amp;lt;String&amp;gt;{
 ...
    public boolean add(Object s) {
        if(!getReifiedElementType().isInstance(s)){
            return false; // Or throw new IllegalArgument()
        }
        return super.add((String)s);
    }
 ...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It extends ArrayList with a &lt;em&gt;String&lt;/em&gt; type parameter, and checks for valid additions based on the type of contained elements.&lt;br /&gt;
This can be done at runtime using reflection. But let&amp;rsquo;s see how that &lt;code&gt;getReifiedElementType()&lt;/code&gt; could get the String type parameter from its superclass.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pre-java 5&lt;/strong&gt;: original &lt;code&gt;getSuperclass()&lt;/code&gt; method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
		Class&amp;lt;?&amp;gt; myRawSuperclass= MyStringList.class.getSuperclass();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, that will only return you an ArrayList.class instance. No type argument information.
This is the runtime super-type of our class (&lt;code&gt;ArrayList&lt;/code&gt;), but it&amp;rsquo;s not the compile time super-type (&lt;code&gt;ArrayList&amp;lt;String&amp;gt;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Post-Java 5&lt;/strong&gt;: &lt;code&gt;Class.getGenericSuperclass()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
Type myGenericSuperClass = MyStringList.class.getGenericSuperclass();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You guessed right. This Type instance has the type arguments. However, it wouldn&amp;rsquo;t let you access it unless you know what sub-typ of &lt;code&gt;Type&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
  ParameterizedType parameterizedSuperclass = (ParameterizedType) myGenericSuperClass;
  Type[] typeArguments = parameterizedSuperclass.getActualTypeArguments();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yeah. You are forced to downcast it. &lt;code&gt;Type&lt;/code&gt; is designed in such a way that has no behavior and it is useless by itself. You need to ask what kind of instance is before doing something with it, and then downcast it.
If you check the returned Type array for arguments, you will find String.class as the only contained element (again, only after downcasting it will you be able to do something useful).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Post-Java 8&lt;/strong&gt;: &lt;code&gt;Class.getAnnotatedSuperclass()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
  AnnotatedType annotatedSuperclass = MyStringList.class.getAnnotatedSuperclass();
  Type typeThatWasAnnotated = annotatedSuperclass.getType();
  Annotation[] annotations = annotatedSuperclass.getAnnotations();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s this AnnotatedType instance you ask?&lt;br /&gt;
It&amp;rsquo;s how Oracle engineers extended reflection to support annotations on types. Since Java 8, you can use annotations on any type declaration. My class can extend an annotated super type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class MyStringList extends ArrayList&amp;lt;@NotNull String&amp;gt; {

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, basically every type can have annotations that specify the type more precisely (although they have no effect on runtime). And the way to know which annotations and which type arguments are used is by calling &lt;code&gt;getAnnotatedSuperclass()&lt;/code&gt;.
But it won&amp;rsquo;t help you much. It uses &lt;code&gt;Type&lt;/code&gt; hierarchy to know the type arguments.&lt;/p&gt;

&lt;h2 id=&#34;ok-let-s-use-the-latest&#34;&gt;Ok, let&amp;rsquo;s use the latest&lt;/h2&gt;

&lt;p&gt;Not only you do have 3 different ways to know your super type, you also have three different non-polymorphic objects.  If you are like me for simplicity&amp;rsquo;s sake, you will say ok, let&amp;rsquo;s use the most complete one, and let&amp;rsquo;s forget about the others (the older ones). Let&amp;rsquo;s use &lt;code&gt;getAnnotatedSuperclass():AnnotatedType&lt;/code&gt; right?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.10pines.com/images/2014-12-02-java-generics-and-inheritance-part-2-threeSuperTypes.jpg&#34; alt=&#34;Three options for super-types&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But what if I have more than one inheritance level? What if I want to know an argument of the super type of my super type? Does AnnotatedType has a super class method as Class does? A super type of List&lt;String&gt; is Collection&lt;String&gt; can I get to it? &lt;strong&gt;Can I traverse my generic lineage? Short answer: no.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;AnnotatedType&lt;/code&gt; doesn&amp;rsquo;t have the concept of inheritance in any of its methods &amp;hellip;. But &amp;hellip;&lt;br /&gt;
&lt;code&gt;AnnotatedType::getType()&lt;/code&gt; allows you to get a &lt;code&gt;Type&lt;/code&gt; instance which doesn&amp;rsquo;t have the concept of inheritance either&amp;hellip;. But&amp;hellip;.&lt;br /&gt;
If &lt;code&gt;Type&lt;/code&gt; is an instance of &lt;code&gt;ParameterizedType&lt;/code&gt;, then you have &lt;code&gt;ParameterizedType::getRawType()&lt;/code&gt; that gives you an instance of &lt;code&gt;Class&lt;/code&gt; and finally you can ask that class its super type again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.10pines.com/images/2014-12-02-java-generics-and-inheritance-part-2-whot.jpg&#34; alt=&#34;Whot?&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let me say it again: from a &lt;code&gt;Class&lt;/code&gt; instance you can have the annotated super type (to get the annotations) then get the generic &lt;code&gt;Type&lt;/code&gt;, cast it to a parameterized type (to get the type arguments), ask its raw class and only then get the super super type. It can&amp;rsquo;t be easier!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.10pines.com/images/2014-12-02-java-generics-and-inheritance-part-2-superSuperType.jpg&#34; alt=&#34;Navigating to a super type&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Oh, one more thing. Each level you go up, you lose the actual type arguments. Why?&lt;br /&gt;
Because you have to pass through a Class instance in order to go up the next level. &lt;code&gt;Class&lt;/code&gt; knows nothing about type arguments.&lt;br /&gt;
In our example, once you get to the super type of ArrayList you will get a type variable &lt;code&gt;E&lt;/code&gt; instead of the actual type argument &lt;code&gt;String&lt;/code&gt;. You will have to manually keep track of type parameters, variable names and type arguments to figure out which is which.&lt;/p&gt;

&lt;p&gt;I have no idea why they just didn&amp;rsquo;t add the annotations and generics information in &lt;code&gt;Type&lt;/code&gt; instead of adding another &lt;code&gt;AnnotatedType&lt;/code&gt;, and chose to have 3 different representations (and two parallel class hierarchies) for type information. Someone should have noticed that something was going wrong when they had almost same class names!&lt;/p&gt;

&lt;h2 id=&#34;one-last-thing-contradiction&#34;&gt;One last thing: contradiction&lt;/h2&gt;

&lt;p&gt;Don&amp;rsquo;t be too harsh on them. Reflection is supposed to represent parts of the language. It&amp;rsquo;s not necessarily complete (it doesn&amp;rsquo;t have to represent everything) but it should be true and precise about the things it does.&lt;/p&gt;

&lt;p&gt;The way java reflection API has evolved to include generics information is the result of an unsolvable contradiction produced by erasure.&lt;br /&gt;
Java language at compile time is not what Java language is at runtime. This may seem obvious, but it&amp;rsquo;s a recent discovery for me: if you have erasure (or any other compilation transformation) then you have two languages.&lt;br /&gt;
The constructs that the language has at compile time don&amp;rsquo;t exist at runtime and that&amp;rsquo;s why reflection has internal contradictions at runtime when it tries to represent compile time concepts. A &lt;code&gt;List&lt;/code&gt; is not the same type at compile-time as &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, however at runtime, they are!&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why at runtime the super class of &lt;code&gt;MyStringList&lt;/code&gt; is &lt;code&gt;ArrayList&lt;/code&gt;, not &lt;code&gt;ArrayList&amp;lt;String&amp;gt;&lt;/code&gt;. That&amp;rsquo;s why you lose the type arguments of a parameterized type when you have a Class.&lt;br /&gt;
Because making the language erase part of itself at compile time generates two different languages. And if you call with the same name the runtime and the compile versions of a language constructs, you will have contradictions.&lt;br /&gt;
Two different personalities that need one representation. That&amp;rsquo;s why you end up with a schizo reflection. You are two inside one.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java generics and inheritance (part 1)</title>
      <link>http://blog.10pines.com/2014/12/02/java-generics-and-inheritance-part-1/</link>
      <pubDate>Tue, 02 Dec 2014 16:51:45 +0000</pubDate>
      
      <guid>http://blog.10pines.com/2014/12/02/java-generics-and-inheritance-part-1/</guid>
      <description>

&lt;h2 id=&#34;types-sets-variables-and-casting&#34;&gt;Types, Sets, variables and casting&lt;/h2&gt;

&lt;p&gt;When you use a compile-time typed language, like Java, you expect that types in each variable will help you by restricting the possibilities for a value. Instead of being able to do everything, you want to do things that are valid in your domain.&lt;/p&gt;

&lt;p&gt;Discussions aside about strong vs weak typing, when you code with types you think of types as sets. A variable can be one of the elements of the implicit set for its type. Thus &lt;code&gt;Integer a&lt;/code&gt; means that variable &lt;em&gt;&amp;lsquo;a&amp;rsquo;&lt;/em&gt; will be one of the elements in the Integer set, and only that.&lt;br /&gt;
If you have a &lt;em&gt;String&lt;/em&gt; variable &lt;em&gt;&amp;lsquo;a&amp;rsquo;&lt;/em&gt; and want to assign its value to a variable &lt;em&gt;&amp;lsquo;b&amp;rsquo;&lt;/em&gt; of type &lt;em&gt;Object&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String a = &amp;quot;A&amp;quot;;
Object b = a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler does an implicit up-casting and you expect that to be a valid operation. The set of &lt;em&gt;Object&lt;/em&gt; instances is a super-set of &lt;em&gt;String&lt;/em&gt; instances. That is basically because Object is a superclass of String and inheritance implies set inclusion.&lt;br /&gt;
But once you upcast, you lose specificity. Your set of possibilities gets bigger and you can&amp;rsquo;t ensure that &lt;em&gt;&amp;lsquo;b&amp;rsquo;&lt;/em&gt; will always be a &lt;em&gt;String&lt;/em&gt;. The value of variable &lt;em&gt;&amp;lsquo;b&amp;rsquo;&lt;/em&gt; could be the &lt;em&gt;String&lt;/em&gt; a, or could be something completely different like the number 1, that belongs to the &lt;em&gt;Integer&lt;/em&gt; set.&lt;/p&gt;

&lt;p&gt;{% img center /images/java-generics-and-inheritance-part-1-VennDeObjectString.jpg &amp;ldquo;Venn diagram of objects&amp;rdquo; %}&lt;/p&gt;

&lt;p&gt;So far, I haven&amp;rsquo;t told you anything new.&lt;/p&gt;

&lt;h2 id=&#34;what-s-wrong-with-generics&#34;&gt;What&amp;rsquo;s wrong with generics?!&lt;/h2&gt;

&lt;p&gt;If you use Java generics, it&amp;rsquo;s fairly probable that you have tried this example wondering what is wrong with the compiler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; stringList = new ArrayList&amp;lt;&amp;gt;();
List&amp;lt;Object&amp;gt;objectList = stringList; 	//error: cannot convert from List&amp;lt;String&amp;gt; to List&amp;lt;Object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; is the set of all lists that have objects inside, then List&lt;String&gt; should be a subset, right? We are just using intuition, but the compiler complains about it.&lt;br /&gt;
To complicate things worse, the compiler will accept that same reasoning for arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        String[] stringArray = new String[0];
        Object[] objectArray = stringArray;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why can arrays be assigned and lists cant&amp;rsquo;t? Have you ever dedicated some thoughts to it? They are both container types, they have both just one element type. What makes those types conceptually different?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.10pines.com/images/java-generics-and-inheritance-part-1-genericsYUNo.jpg&#34; alt=&#34;Generics YU&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-reason&#34;&gt;The reason&lt;/h2&gt;

&lt;p&gt;Reading the authors of generics you can find a very good reason for it. Remember, at that time, they were trying to generify collections (having only java 1.4 on their hands).&lt;br /&gt;
If you allow a list of strings to be upcasted to a list of objects and operated as a list of objects, you can do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  List&amp;lt;String&amp;gt; stringList = new ArrayList&amp;lt;String&amp;gt;();
  List&amp;lt;Object&amp;gt; objectList = stringList;  // Let&#39;s pretend this is possible
  objectList.add(1); // Hey, 1 is not a String!
  String element = stringList.get(0); // Wonder what will happen...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since it&amp;rsquo;s an object list, why can&amp;rsquo;t you just put a number inside. It&amp;rsquo;s an object right? And what happens when the reference to that same list instance but with a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; type tries to get the added element?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String element = stringList.get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yeah! KaBoom. ClassCastException!&lt;br /&gt;
Wait, what? Why do I have a cast exception if I&amp;rsquo;m not even casting?&lt;br /&gt;
To understand what&amp;rsquo;s is going on, we need to see the implicit code there. When you use generics you have what they called &lt;em&gt;&amp;ldquo;erasure&amp;rdquo;&lt;/em&gt;: the compiler modifies your code and some of the generic information is lost. This is the actual runtime code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String element = (String) stringList.get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You are not only casting, you are down-casting (which it&amp;rsquo;s not runtime-safe). The return type of get() method, in runtime, is &lt;em&gt;Object&lt;/em&gt;, not &lt;em&gt;String&lt;/em&gt;. That&amp;rsquo;s why, in runtime, you need to downcast to String.&lt;br /&gt;
The compiler does it for you, but at the cost of assuming that the list only contains &lt;em&gt;Strings&lt;/em&gt;. That assumption can be made at compile time if you avoid addition of other non &lt;em&gt;String&lt;/em&gt; objects. How do they do that?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;At compile time, let&amp;rsquo;s not allow the list to be used for anything else than &lt;em&gt;Strings&lt;/em&gt;. So list of objects is out of the question.&lt;/strong&gt;
There are, of course, other solutions to this problem (see &lt;a href=&#34;http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&#34;&gt;Covariance and Contravariance&lt;/a&gt; ) but we will stick to Java solution in this article.&lt;/p&gt;

&lt;p&gt;If you know what you are doing, there&amp;rsquo;s one way to workaround this &lt;em&gt;generics&lt;/em&gt; restriction. To see it graphically at compile time, we have three types &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt; which is the &amp;ldquo;raw&amp;rdquo; type, represented as sets:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.10pines.com/images/java-generics-and-inheritance-part-1-VennListObjectListString.jpg&#34; alt=&#34;Venn diagram of lists&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The only way to escape this rule, at compile time, is to move to the super-set, and then go down to the other sub-set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; stringList = new ArrayList&amp;lt;String&amp;gt;();
List&amp;lt;Object&amp;gt; objectList = (List)stringList;  // no error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fool the compiler by up-casting to &lt;code&gt;List&lt;/code&gt; so it doesn&amp;rsquo;t know which kind of elements is in the list, and then down-cast to &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; which is accepted. Why is that allowed and &lt;code&gt;(List&amp;lt;Object&amp;gt;)stringList&lt;/code&gt; isn&amp;rsquo;t, it&amp;rsquo;s out of my grasp.&lt;br /&gt;
Just to warn you: if you manage to do this, you may have &lt;em&gt;ClassClassExceptions&lt;/em&gt; in runtime.&lt;/p&gt;

&lt;h2 id=&#34;but-arrays&#34;&gt;But arrays!&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.10pines.com/2014/12/02/java-generics-and-inheritance-part-2&#34;&gt;On the next part of this article&lt;/a&gt;, I&amp;rsquo;ll show you why this doesn&amp;rsquo;t happen with arrays, and the implications for reflection.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Is Java Dead?</title>
      <link>http://blog.10pines.com/2014/06/05/is-java-dead/</link>
      <pubDate>Thu, 05 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.10pines.com/2014/06/05/is-java-dead/</guid>
      <description>

&lt;p&gt;The answer is: of course not!!, but now that I got your attention surely due to
the title that mimics the lately hot &lt;a href=&#34;http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html&#34;&gt;&lt;em&gt;&amp;ldquo;Is TDD Dead?&amp;rdquo;&lt;/em&gt;&lt;/a&gt; discussion
started by &lt;a href=&#34;https://twitter.com/dhh&#34;&gt;@dhh&lt;/a&gt;, I would like to concentrate on the real objective of
this post that I think it is really more important: is Java taking the right
road? or in other words, are the last changes in Java 8 &lt;em&gt;&amp;ldquo;good&amp;rdquo;&lt;/em&gt; ones or not?&lt;/p&gt;

&lt;p&gt;So, let me start saying why I think Java is not dead, to stop any language fight
from the beginning even though the reason is a no brainer. It is not dead
because despite how old Java is becoming and how it is starting to show its
wrinkles through the lack of type inference, numbers not being objects, etc.,
it is still widely used, it has a big and productive community and I think that
almost for sure, its community is the one that more open source projects has
produced. A language it is not only used by its technicals features but also for
the community it has, the projects it supports, etc.&lt;/p&gt;

&lt;p&gt;Having said that and made that clear, let&amp;rsquo;s now concentrate only on the
technical part. So, are the changes of Java 8 &lt;em&gt;&amp;ldquo;good&amp;rdquo;&lt;/em&gt;? Are they useful? How can
we measure if they are &lt;em&gt;&amp;ldquo;good or bad&amp;rdquo;&lt;/em&gt;? The plain answer is, it depends, it
always depends :-). But, it depends on what?. A few months ago after a talk I
gave at the &lt;a href=&#34;http://scrumbolivia.com/?page_id=825&#34;&gt;Scrum Gathering Bolivia&lt;/a&gt;, an attendee came to talk to
me because I made some comments about Python&amp;rsquo;s issues. He told me: &amp;ldquo;I&amp;rsquo;m really
happy with Python! I think I&amp;rsquo;m more productive that I used to be with the
language I used before&amp;rdquo;. I asked him which language was that, and he said:
&amp;ldquo;Java&amp;rdquo;. So yes, it depends. If you are used to program with Java, suffering due
to its archaic type system, the lack of closures and its verbosity, Python looks
like the holy grail, but is it?&lt;/p&gt;

&lt;p&gt;Programming languages reflect the knowledge, beliefs and ways to solve problems
the authors of those languages have. But not only that, they carry on their
shoulders the heavy weight of its history and that is, as I understand, what it
is killing Java, or at least what it is not making Java get any better when you
compare it with other languages.&lt;/p&gt;

&lt;p&gt;Of course that for Java programmers, version 8 has many interesting features,
but from the point of view of other programming languages, how &lt;em&gt;&amp;ldquo;good&amp;rdquo;&lt;/em&gt; are
they? Are these changes making Java a &amp;ldquo;better&amp;rdquo; language or just keeping it from
its (in)evitable dead end? I propose you to analyze some of the Java 8 changes
from both perspectives and see where we get.&lt;/p&gt;

&lt;h2 id=&#34;new-date-and-time-model-so-called-api&#34;&gt;New Date and Time model (so called API)&lt;/h2&gt;

&lt;p&gt;It is about time to throw away the ugly, full of design errors, best example of
all the things you don&amp;rsquo;t have to do, &lt;strong&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/strong&gt; class. That class contains
almost all the design flaws you can look for, like a misleading name because its
instances do not represent calendars but dates, or dates with time, or&amp;hellip; wait a
moment, another problem, it does not represent just one thing but many! it does
not follow the &lt;em&gt;&amp;ldquo;Single Responsibility Principle&amp;rdquo;&lt;/em&gt; and not only that, it allows
you to represent invalid dates as February 31st of 2014, or change dates when
dates should be immutables like the numbers and many other objects. You have no
idea the amount of people I interviewed with the misconception of what a
&lt;strong&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/strong&gt; is and what a &lt;strong&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/strong&gt; is due to this really bad abstraction
(all Java programmers).&lt;/p&gt;

&lt;p&gt;So, the new date/time model is &lt;em&gt;&amp;ldquo;good&amp;rdquo;&lt;/em&gt;, it is an advance towards less
misunderstanding, it provides new nouns that makes the language grow and allows
us to talk and think about days of month, like &lt;code&gt;December 25th&lt;/code&gt; (with the
abstraction &lt;code&gt;MonthDay&lt;/code&gt;) or months of year as &lt;code&gt;April 2014&lt;/code&gt; (with &lt;code&gt;YearMonth&lt;/code&gt;).
Finally, with the new time model not everything is a &lt;code&gt;Calendar&lt;/code&gt;!.&lt;/p&gt;

&lt;p&gt;We can also express &amp;ldquo;measures of time&amp;rdquo; with a &lt;code&gt;Duration&lt;/code&gt; and even &lt;code&gt;Years&lt;/code&gt;! Yes!
they broke the fear of &amp;ldquo;optimization&amp;rdquo; that makes most programmers represent
years with integers! We all know that a number is not a year, we all know that a
number does not respond to &lt;code&gt;isLeap&lt;/code&gt; but it makes a lot of sense for a &lt;code&gt;Year&lt;/code&gt; to
answer that, so I toast for this new time model that prioritizes good
abstractions over performance/space.&lt;/p&gt;

&lt;p&gt;Yes, this model is &amp;ldquo;good&amp;rdquo;, but is it? Let&amp;rsquo;s see how it compares to a date/time
model of other languages. In this case the one implemented in &lt;a href=&#34;http://pharo.org/&#34;&gt;Pharo&lt;/a&gt; (an
open source implementation of Smalltalk) called &lt;a href=&#34;http://smalltalkhub.com/#!/~HernanWilkinson/Chalten&#34;&gt;Chalten&lt;/a&gt;. (You can
read about it in this &lt;a href=&#34;http://www.sciencedirect.com/science/article/pii/S1477842405000424&#34;&gt;paper&lt;/a&gt; published in 2005). With Chalten you can
not only represent those elements that you can with Java 8 but also many more,
starting with real measures of time because it uses an algebraic model that
allows you to represent any type of measure (&lt;a href=&#34;http://smalltalkhub.com/#!/~HernanWilkinson/Aconcagua&#34;&gt;Aconcagua&lt;/a&gt;). With
Chalten you can represent &lt;em&gt;1 day&lt;/em&gt;, &lt;em&gt;3 months&lt;/em&gt;, &lt;em&gt;5 year&lt;/em&gt;, &lt;em&gt;7 centuries&lt;/em&gt; and any
other kind of time measure like &lt;em&gt;2 semesters&lt;/em&gt; (if you create the unit
&lt;strong&gt;semester&lt;/strong&gt;). There is not only a &lt;code&gt;Duration&lt;/code&gt; that it is limited to the time
units it provides through messages like &lt;code&gt;toHours&lt;/code&gt;, &lt;code&gt;toMinutes&lt;/code&gt;, &lt;code&gt;toNanos&lt;/code&gt;, etc.
but the possibility to create any time unit you need or want.&lt;/p&gt;

&lt;p&gt;Chalten is based on an analogy that sees &lt;em&gt;Time&lt;/em&gt; as a line of different
granularities where you can zoom in and zoom out, and therefore you can
represent intervals in those lines, vectors and segments of any granularity and
apply the common well known operations like intersection, union, iteration, etc.
on any of them.&lt;/p&gt;

&lt;p&gt;With Chalten you can represent relative points in time like &lt;em&gt;&amp;ldquo;20 days from now&amp;rdquo;&lt;/em&gt;
or &lt;em&gt;&amp;ldquo;3 months since April 2014&amp;rdquo;&lt;/em&gt;. Those relative points can be filtered with the
filtering rules of a &amp;ldquo;calendar&amp;rdquo;, as a labor calendar that defines Saturdays and
Sundays as not working days, and therefore &amp;ldquo;20 days from now&amp;rdquo; will not be the
same applied that calendar that to another one where Saturdays are workable
days. These are, to name a few, features Chalten has since 2005 that the new
Java time model lacks.&lt;/p&gt;

&lt;p&gt;So, is the new java date/time model &amp;ldquo;good&amp;rdquo;? It is better than the previous one.
Is it the best one? Sadly it is not if you compare it to other long ago known
solutions. But it definitely does not hurts you like other &amp;ldquo;new features&amp;rdquo; of
Java 8.&lt;/p&gt;

&lt;h2 id=&#34;the-so-waited-closures-wait-lambdas&#34;&gt;The so waited Closures… wait Lambdas!&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start making clear that &lt;strong&gt;Closures&lt;/strong&gt; are not the same as &lt;strong&gt;Lambdas&lt;/strong&gt;, not
even &lt;strong&gt;Full Closures&lt;/strong&gt;. The definition of these concepts will vary depending on
the literature, programming language, etc., but mainly the difference is how
they bind. With Java Lambdas you can not change variables of the current
lexicography context, where with Closures like the ones you have in C# you can,
but you can even do more with Full Closures where the return also binds to the
current context as in Ruby and Smalltalk.&lt;/p&gt;

&lt;p&gt;So, are Java Lambdas &amp;ldquo;good&amp;rdquo;? Well, definitely they are better that the freakish
anonymous classes because all the boilerplate to use them is gone, but in the
end are almost the same. The Java lambdas are mainly syntax sugar to avoid using
certain kind of anonymous classes and a minor (good) change on how they bind.&lt;/p&gt;

&lt;p&gt;Java lambdas will allow you to code better, to create better abstractions, to
reduce &amp;ldquo;lines of repeated code&amp;rdquo; but still, Java lambdas are not the &amp;ldquo;best
solution&amp;rdquo;. Full closures would be better as proved by Ruby, Smalltalk, Scheme
and the famous &lt;a href=&#34;http://library.readscheme.org/page1.html&#34;&gt;&amp;ldquo;Lambda: The ultimate x&amp;rdquo;&lt;/a&gt; series of papers
written of the last half of the 70s&amp;hellip; yes, a long time ago.&lt;/p&gt;

&lt;p&gt;Why Java 8 does not have Full Closures or at least Closures? Definitely not
because they are not good, definitely not because they are difficult or very
hard to implement, Ruby has them since its creation circa the same year as Java,
Scheme has them since the mid 70s and Smalltalk too.&lt;/p&gt;

&lt;h2 id=&#34;null-considered-harmful&#34;&gt;Null considered harmful&lt;/h2&gt;

&lt;p&gt;If I took @dhh&amp;rsquo;s &amp;ldquo;Is TDD Dead&amp;hellip;&amp;rdquo; phrase, why not used the so famous &amp;ldquo;x
considered harmful&amp;rdquo; derived from Dijkstra&amp;rsquo;s well know &amp;ldquo;Goto considered harmful&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;I see with great joy that we are starting to realize that &lt;code&gt;null&lt;/code&gt; is not a good
idea. We are starting to see more and more languages that are trying to provide
a solution to all the problems &lt;code&gt;null&lt;/code&gt; provokes. Even the newly Apple&amp;rsquo;s Swift
provides some aid allowing variables to reference &lt;code&gt;nil&lt;/code&gt; or not, and send
messages with a &amp;ldquo;?&amp;rdquo; at the end that helps avoiding to check for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;nil&lt;/code&gt; on
each message send.&lt;/p&gt;

&lt;p&gt;What is Java 8 doing about it? It provides an abstraction called &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;
that responds to messages like &lt;code&gt;ifPresent&lt;/code&gt; (encapsulating the hated
&lt;code&gt;if x==null&lt;/code&gt;), &lt;code&gt;orElse(T anObject)&lt;/code&gt; that returns the wrapped object or the
parameter &lt;code&gt;anObject&lt;/code&gt; if the wrapped one is &lt;code&gt;null&lt;/code&gt;, and some others.&lt;/p&gt;

&lt;p&gt;At first sight looks good, it is an abstraction that encapsulates all the
&lt;code&gt;if x==null&lt;/code&gt; we are forced to write if we want to produce robust software. Looks
like a step forward, but is it? Let see what other languages have, for example
Ruby.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start pointing a big difference. In Ruby &lt;code&gt;nil&lt;/code&gt; is an object, not a
&lt;strong&gt;&amp;ldquo;reserved word&amp;rdquo;&lt;/strong&gt; that the compiler recognizes and treats specially. So
because &lt;code&gt;nil&lt;/code&gt; is an object it can answer messages like &lt;code&gt;nil?&lt;/code&gt; that encapsulated
the &lt;code&gt;if x==nil&lt;/code&gt; and many other you would like. The same in Smalltalk, &lt;code&gt;nil&lt;/code&gt;
responds messages like &lt;code&gt;ifNil:&lt;/code&gt; that encapsulates the
&lt;code&gt;if anObject isNil then ...&lt;/code&gt; in just one &lt;code&gt;anObject ifNil ...&lt;/code&gt;, and &lt;code&gt;ifNotNil:&lt;/code&gt;,
and &lt;code&gt;ifNil:ifNotNil:&lt;/code&gt;, etc. All very handy messages and all the new messages you
may need because &lt;code&gt;nil&lt;/code&gt; is an object and therefore you can extend its protocol.&lt;/p&gt;

&lt;p&gt;So what is the difference? The difference is that in Ruby and Smalltalk you
don&amp;rsquo;t need a special abstraction to handle &lt;code&gt;null&lt;/code&gt;, it is just it!. There is no
need for an &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; abstraction to wrap an object and respond messages
you would like &lt;code&gt;null&lt;/code&gt; to answer.&lt;/p&gt;

&lt;p&gt;With time, we will start to realize that the &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; class has the same
issues that the &lt;code&gt;Integer&lt;/code&gt; class, the &lt;code&gt;Long&lt;/code&gt; class and all the wrappers of the
data types used to represent numbers in Java because numbers are not objects. It
looks like we have learn nothing from the mistake of not having objects all the
way down. Let&amp;rsquo;s see some examples starting to interact with the wrapped object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
Optional&amp;lt;String&amp;gt; aString = Optional.of(&amp;quot;something&amp;quot;);
aString.charAt(1); &amp;lt;-- It does not compile because aString&#39;s type is Optional
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can guess, the example does not compile in the line 3 because &lt;code&gt;aString&lt;/code&gt;
is not really a &lt;code&gt;String&lt;/code&gt; but an &lt;code&gt;Optional&lt;/code&gt;. So we have to send the message &lt;code&gt;get&lt;/code&gt;
to &lt;code&gt;aString&lt;/code&gt; to get the real String (does it sound as a tongue-twister? I
promise it is not my purpose :-) ):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
Optional&amp;lt;String&amp;gt; aString = Optional.of(&amp;quot;something&amp;quot;);
aString.get().charAt(1); &amp;lt;-- Now it works because we are getting the wrapped object
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Therefore, everytime we want to access the &amp;ldquo;real&amp;rdquo; object we need to send &lt;code&gt;get&lt;/code&gt;
to the optional one. So if we want to send many messages we have to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
Optional&amp;lt;String&amp;gt; aString = Optional.of(&amp;quot;something&amp;quot;);
aString.get().charAt(1);  aString.get().charAt(1);
aString.get().charAt(2);
aString.get().charAt(3);
aString.get().charAt(4);... etc
... etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To avoid sending that many &lt;code&gt;get&lt;/code&gt;, we could just do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
Optional&amp;lt;String&amp;gt; aString = Optional.of(&amp;quot;something&amp;quot;);
...
String realString = aString.get();
realString.charAt(1);
realString.charAt(2);
realString.charAt(3);
realString.charAt(4);
... etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if we do this, why are we using &lt;code&gt;Optional&lt;/code&gt; for? We can make a mistake and
assign &lt;code&gt;null&lt;/code&gt; to &lt;code&gt;realString&lt;/code&gt; and get back to what we wanted to avoid in the
first place. So &lt;code&gt;Optional&lt;/code&gt; does not really stops programmers to send messages to
&lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s go a little bit deeper. A common use case is to stop execution and
return from a method if a variable references &lt;code&gt;null&lt;/code&gt;, like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
if (aVariable==null) return;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How does the new abstraction help us in this case? Let&amp;rsquo;s see, it would be great
to write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
Optional&amp;lt;String&amp;gt; aString = Optional.ofNullable(null);
aString.ifNotPressent({return;});
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it is not possible because there is no message &lt;code&gt;ifNotPresent&lt;/code&gt; in &lt;code&gt;Optional&lt;/code&gt;!
just &lt;code&gt;ifPresent&lt;/code&gt;. Let&amp;rsquo;s see how we can do the opposite with &lt;code&gt;ifPresent&lt;/code&gt;. Let&amp;rsquo;s
say I want to return if the variable is not referencing &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
Optional&amp;lt;String&amp;gt; aString = Optional.ofNullable(&amp;quot;something&amp;quot;);
aString.ifPresent(aNotNullString -&amp;gt;{return;});
System.out.println(&amp;quot;got here&amp;quot;);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What do you say? does it get to &lt;em&gt;&amp;ldquo;got here&amp;rdquo;&lt;/em&gt;? :-) or does it return from the
method where this code is? Sadly it gets to &lt;em&gt;&amp;ldquo;got here&amp;rdquo;&lt;/em&gt;, it does not return as
one would expect because lambdas are not full closures! That return exits the
lambda but not the method where the return is written.&lt;/p&gt;

&lt;p&gt;So, how do we get out of this mess? How can return from a method if an
&lt;code&gt;Optional&lt;/code&gt; is wrapping &lt;code&gt;null&lt;/code&gt;? Writing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
if (!aString.isPresent()) return;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please, you tell me the difference with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
if (aString==null) return;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What have we gain? Only more complexity. Are there any alternatives? How do
other languages treat this problem? In languages with full closures where null
is an object like Ruby or Smalltalk, you could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-smalltalk&#34;&gt;aString ifNil: [ ^something ] (the ^ means return)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that is all folks, simple, direct and does what you expect, if &lt;code&gt;aString&lt;/code&gt;
references &lt;code&gt;nil&lt;/code&gt; returns &amp;ldquo;something&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;So, not only the &lt;code&gt;Optional&lt;/code&gt; abstraction is a halfway solution (a fullway
solution would be to make &lt;code&gt;null&lt;/code&gt; a first class object) but the lack of full
closures do not really help much here, on the contrary.&lt;/p&gt;

&lt;p&gt;To end this section, I would like you to think a little bit more about this
problem. Is there another solution besides making &lt;code&gt;null&lt;/code&gt; a first class object
and have full closure to solve this problem? I think there is. I think the best
solution is to get rid of &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;nil&lt;/code&gt; completely. Not even the &amp;ldquo;?&amp;rdquo; of Swift or
C#. The truth is that we do not need &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;nil&lt;/code&gt;, it has so many meanings, we
use it so badly, it is so error prone that the best solution would be to remove
that idea completely. So instead of &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;nil&lt;/code&gt; we would have an abstraction
called &lt;code&gt;UninitializedVariable&lt;/code&gt; to indicate that case, another called
&lt;code&gt;NoSuperclass&lt;/code&gt; to point out the a class has no super class, or &lt;code&gt;EndOfList&lt;/code&gt; to
indicate the we got to the end of a linked list or &lt;code&gt;UndefinedAddress&lt;/code&gt; to
represent the fact that the user did not specify his/her address and so on.
Think about it for a moment, you may like it :-) but if not, watch Tony Hoare&amp;rsquo;s
opinion about &lt;a href=&#34;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&#34;&gt;&amp;ldquo;Null References: The billon dollar mistake&amp;rdquo;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Are the Java 8 changes &amp;ldquo;good&amp;rdquo;? Some of them yes, the date/time model is
definitely better of what we had, the way to represent code with lambdas is
definitely better that anonymous classes but sadly not good enough, and the
&lt;code&gt;Optional&lt;/code&gt; abstraction does not solve the real problem but adds complexity. Some
of these changes are good if you are a Java programmer but some are not, even if
you are a Java programmer, because they add unnecessary complexity, and if you
are not a Java programmer, most of them are still ancient code, like for Ruby or
Smalltalk programmers, even for people that work with C#.&lt;/p&gt;

&lt;p&gt;You may wonder what it is the goal of this post. Is it to talk/promote Smalltalk
or Ruby? Is it to show that I don&amp;rsquo;t like Java? Not really. I wrote it because
I&amp;rsquo;m afraid that for people that only work with Java these changes may look
great, a step forward a better life. My fear is that those people may think that
the only way to treat &lt;code&gt;null&lt;/code&gt; is with &lt;code&gt;Optional&lt;/code&gt; because all the know is &lt;em&gt;&amp;ldquo;the
Java way&amp;rdquo;&lt;/em&gt;, they only live in the &lt;em&gt;&amp;ldquo;Java world&amp;rdquo;&lt;/em&gt;. My fear is that I will now
start interviewing people that instead of confusing Dates with Calendars will
confuse Closure with Lambda, people that will not see that instead of hiding the
problem under the carpet as with Optional, we should get rid of the real dust.&lt;/p&gt;

&lt;p&gt;So, I wrote this post in an attempt to open programmers mind, to show them that
there are other places too look at and learn, even if you make a living from
Java. If you really love Java, the only way to get a better Java is forcing
real, profound changes on it, not just changes that keeps back-compatibility.&lt;/p&gt;

&lt;p&gt;Will Java ever make profound changes on it? Will Java take better paths? I think
it will not. The back compatibility principle they apply is stopping Java to
evolve better. We will never see Java without &lt;code&gt;null&lt;/code&gt; or at least a first class
object null, we will never see Java with a better type system, we will never see
numbers as objects in Java; its back compatibility does not simple allow it.&lt;/p&gt;

&lt;p&gt;I would like to finish with something &lt;a href=&#34;http://en.wikipedia.org/wiki/Alan_Kay&#34;&gt;Alan Kay&lt;/a&gt; said about Smalltalk, its
creation, when discussing the future of the language with his group composed by
great minds like &lt;a href=&#34;http://en.wikipedia.org/wiki/Adele_Goldberg_(computer_scientist)&#34;&gt;Adele Goldberg&lt;/a&gt; and &lt;a href=&#34;http://en.wikipedia.org/wiki/Dan_Ingalls&#34;&gt;Dan Ingalls&lt;/a&gt; among others.
Basically he was not happy making Smalltalk a commercial language because he
knew that after releasing it, Smalltalk would stop evolving because the priority
would be to satisfy users/customers needs (backward compatibility among them)
instead of creating new features and experimenting new ideas.&lt;/p&gt;

&lt;p&gt;In other words, when a programming language hits the market its future is
defined.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>akka, un framework con actores en la jvm</title>
      <link>http://blog.10pines.com/2012/02/29/akka-un-framework-con-actores-en-la-jvm/</link>
      <pubDate>Wed, 29 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://blog.10pines.com/2012/02/29/akka-un-framework-con-actores-en-la-jvm/</guid>
      <description>

&lt;h2 id=&#34;introducción&#34;&gt;Introducción&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://akka.io/&#34;&gt;Akka&lt;/a&gt; es un framework para programación concurrente, distribuida y tolerante a fallos en la JVM, principalmente basado en Scala pero que también soporta Java. Akka implementa el modelo de Actores (&lt;a href=&#34;http://en.wikipedia.org/wiki/Actor_model&#34;&gt;http://en.wikipedia.org/wiki/Actor_model&lt;/a&gt;) que se basa en entidades llamadas &lt;em&gt;Actores&lt;/em&gt; que se ejecutan concurrentemente y se envían mensajes de forma asincrónica entre sí. Este mismo modelo es el que implementa el lenguaje de programación Erlang. Akka también implementa Software Transactional Memory, un mecanismo de memoria transaccional que es una alternativa al locking para acceder a estructuras de datos en memoria compartidas, y que es similar al que está implementado en el lenguaje Clojure.&lt;/p&gt;

&lt;p&gt;En este articulo, veremos como utilizar Akka en Java, utilizando Actores y STM para resolver un problema de concurrencia simple pero que involucra multiples variables que se actualizan a la vez, con un cierto nivel de contención. Vamos a ver varias implementaciones, explorando las posibilidades de Akka, con el código fuente disponible para bajar. Utilizaremos la versión Akka 1.2.&lt;/p&gt;

&lt;h2 id=&#34;actores&#34;&gt;Actores&lt;/h2&gt;

&lt;p&gt;Los actores son entidades que ejecutan concurrentemente y se envían mensajes asincronicos entre sí (si bien es posible implementar mensajes sincronicos). El modelo de actores está pensado en base a la idea de que los actores no comparten estado (aunque más adelante veremos una forma de que compartan estado), y que de esta manera no hay problemas de locking para acceder al estado: El estado es único a cada actor, y cada actor solo procesa un mensaje a la vez. El modelo de actores es inherentemente distribuido: Como cada actor no comparte estado con el resto de los actores, estos pueden estar ubicados en diferentes JVMs en diferentes nodos, y que estén en la misma JVM puede verse como un caso particular, o una optimización.&lt;/p&gt;

&lt;p&gt;Los actores en Akka son extremadamente livianos. Por cada actor, el framework Akka asigna unos 600 bytes y por defecto cada actor no corre necesariamente en un thread de la JVM, sino que Akka implementa una planificación propia al estilo &lt;em&gt;green thread&lt;/em&gt;, esto permite tener una gran cantidad de Actores corriendo en una JVM. De todas maneras esto es configurable y es posible asignar un thread &lt;em&gt;dedicado&lt;/em&gt; a un actor.&lt;/p&gt;

&lt;h2 id=&#34;software-transactional-memory&#34;&gt;Software Transactional Memory&lt;/h2&gt;

&lt;p&gt;El mecanismo de Software Transactional Memory, o STM, es un mecanismo que permite acceder a variables transacccionales dentro de una transacción con las propiedades ACI de ACID (sin la D de durabilidad, porque es memoria volátil): Atomicidad, Consistencia, Aislamiento (Isolation). Lo unico que hay que hacer es envolver en una transacción los accesos a las variables (ya sea lectura o escritura).&lt;/p&gt;

&lt;p&gt;La memoria transaccional tiene varias ventajas con respecto al locking:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No puede haber deadlocks.&lt;/li&gt;
&lt;li&gt;Las transacciones pueden componerse: Es posible tomar dos operaciones transaccionales y combinarlas y envolverlas en una transacción. Esto no se puede hacer de una manera simple utilizando unicamente locks.&lt;/li&gt;
&lt;li&gt;Permite aprovechar al maximo el paralelismo porque al no haber locks, se reduce la contención (si bien es posible generar una congestión en el acceso a una única variable).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;un-problema-a-resolver-moving-robots&#34;&gt;Un problema a resolver: Moving Robots&lt;/h2&gt;

&lt;p&gt;El problema que vamos a resolver está inspirado en una demostración del mecanismo de STM de Clojure, llamado &amp;ldquo;ants-demo&amp;rdquo;, que consiste en una simulación de hormigas que se mueven por un mundo, moviendose y comiendo comida, donde todas las hormigas funcionan concurrentemente alterando el mundo, y donde cada tanto debe mostrarse por pantalla el estado actual del mundo de forma consistente. Nuestro problema es más sencillo, e involucra una cuadrilla con casilleros de NxM, donde cada casillero puede estar vacío o tener un robot, y concurrentemente cada cierto tiempo los robots tratan de moverse en una de las 4 direcciones, si hubiera en el casillero destino otro robot ya ubicado, el robot se &amp;ldquo;detiene&amp;rdquo; por la presencia de su colega robot, y no avanzará.&lt;/p&gt;

&lt;p&gt;Claramente es necesario tener una vista consistente y ordenada para acceder al tablero en todo momento, porque pueden suceder cosas como que dos robots traten de acceder al mismo tiempo a un mismo casillero, y solo uno tiene que moverse. A a su vez es importante poder leer el tablero de forma consistente para mostrarlo en pantalla, esto es necesario porque no queremos que mientras que vamos leyendo el tablero para mostrarlo se vaya actualizando y aparezcan robots duplicados (porque cuando leimos el primer casillero, el robot estaba ahi, y cuando leimos el segundo, el robot ya se movio) o robots invisibles (porque cuando leimos el primer casillero, el robot no estaba ahi, pero luego se movio a esa posicion cuando leimos el segundo donde estaba originalmente).&lt;/p&gt;

&lt;p&gt;Existen entonces básicamente dos tipos distintos de cambios de estado y consulta del sistema:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Movimiento de un robot a otro casillero, el cual incluye una consulta al estado del casillero destino (si tiene o no tiene un robot), y en base a esa consulta se decide si moverse o no. Esto no es tan simple como parece, porque tenemos que asegurarnos que si consultamos el estado y este no tiene un robot, al momento de asignar nuestro robot ese estado no puede ser modificado en el medio.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Consultar el estado del tablero en su integridad, consistentemente. Esto se hace cada cierto tiempo y con una menor frecuencia que el movimiento de los robots.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;La forma más simple de lidiar con este problema de concurrencia es simplemente tener un lock global para todo el tablero, cada vez que se va a mover un robot, o cada vez que se va a mostrar por pantalla. El problema de este esquema es que a medida que el tablero crece y la cantidad de robots crece, hay cada vez más contención sobre ese lock, cuando en realidad, para mover un robot a un casillero, solamente nos interesan dos casilleros: el casillero origen y el casillero destino (para mostrarlo, en ese caso sí interesa la totalidad de los casilleros).&lt;/p&gt;

&lt;p&gt;Otra alternativa es utilizar locking casillero a casillero, en este caso el problema es evitar los deadlocks, cosa que no es tan trivial ya que tanto para mover un robot como para mostrarlo se necesitarían varios locks. Nosotros vamos a intentar resolverlo en Akka, sin locking.&lt;/p&gt;

&lt;h2 id=&#34;primer-implementación-actores-no-tipados-sin-stm&#34;&gt;Primer implementación, actores no tipados sin STM&lt;/h2&gt;

&lt;p&gt;En Akka hay dos tipos de actores, actores no tipados y actores tipados. Vamos a utilizar primero los actores no tipados, que son aquellos que heredan de la clase &lt;code&gt;UntypedActor&lt;/code&gt; y solo deben implementar el método &lt;code&gt;onReceive&lt;/code&gt;, que recibe un objeto mensaje por parámetro. El mensaje es un POJO, que no tiene ninguna restricción, excepto que es inmutable (aunque como veremos más tarde, hay una forma de relajar esta restricción).&lt;/p&gt;

&lt;p&gt;Definimos entonces dos tipos de actores, &lt;code&gt;Robot&lt;/code&gt; y &lt;code&gt;Casillero&lt;/code&gt;. Cada &lt;code&gt;Robot&lt;/code&gt; conoce a su casillero actual, y cada &lt;code&gt;Casillero&lt;/code&gt; conoce a su &lt;code&gt;Robot&lt;/code&gt; actual, y a sus vecinos en cada una de las 4 direcciones. Cada &lt;code&gt;Robot&lt;/code&gt; tiene un nombre que es un string que se utiliza para poder mostrar el tablero en pantalla, imprimiendo el nombre del robot en cada casillero o un &amp;ldquo;#&amp;rdquo; si el casillero esta vacío.&lt;/p&gt;

&lt;p&gt;Cada actor puede responder a los siguientes mensajes:&lt;/p&gt;

&lt;h3 id=&#34;robot&#34;&gt;Robot&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MoveteEnDireccion&lt;/code&gt;: Al recibir este mensaje, el robot se moverá en una dirección especificada dentro del mensaje. En el loop principal del programa habrá un thread que manda estos mensajes a todos los actores Robot en determinados intervalos de tiempo, con direcciones aleatorias.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DameTuNombre&lt;/code&gt;: Devuelve el nombre del robot, para poder imprimir su nombre.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;NuevoCasillero&lt;/code&gt;: Contiene una referencia al Casillero el cual será su nuevo casillero, utilizado tanto para inicializar la posición del robot como respuesta al movimiento del robot, en ambos casos actualiza el casillero actual del robot.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;casillero&#34;&gt;Casillero&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MovemeA&lt;/code&gt;: Mensaje que instruye que el robot contenido en el casillero, debe moverse hacia una direccion especificada en el mensaje.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;RecibiRobot&lt;/code&gt;: Mensaje que contiene una referencia a un robot, y debe asignarse como el robot actual del casillero, respondiendo con un ResultadoMovimiento si pudo asignarlo o no (porque ya tenia otro robot actualmente).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ResultadoMovimiento&lt;/code&gt;: Mensaje que unicamente se recibe como respuesta a un RecibiRobot.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DameTuRobot&lt;/code&gt;: Devuelve el robot actualmente contenido, necesario para mostrar el tablero en pantalla.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;TusVecinosSon&lt;/code&gt;: Inicializa los vecinos del casillero en cada direccion.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Entonces, el mecanismo por el cual los robots se mueven es el siguiente:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;El robot recibe el mensaje MoveteEnDireccion.&lt;/li&gt;
&lt;li&gt;El robot un mensaje MovemeA al Casillero, con la dirección. Lo envía de forma sincronica, es decir, el actor robot se bloquea esperando una respuesta y no puede recibir más mensajes.&lt;/li&gt;
&lt;li&gt;El casillero envía el mensaje RecibiRobot al casillero vecino que se encuentra en esa posicion (si hubiera alguno, ya que en caso de estar contra una pared), y también de forma sincronica espera una respuesta.&lt;/li&gt;
&lt;li&gt;El casillero vecino que recibe el mensaje RecibiRobot, si no tiene ningun robot, lo asigna como el robot actual, y responde ResultadoMovimiento con true dentro, o con false en caso contrario.&lt;/li&gt;
&lt;li&gt;El casillero original recibe la respuesta del casillero vecino, y responde al robot con un mensaje NuevoCasillero con el casillero vecino, si pudo moverse a dicho casillero, o con el mismo casillero original, si no pudo moverse.&lt;/li&gt;
&lt;li&gt;El robot recibe el mensaje de respuesta, y actualiza su casillero actual.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;``` java Robot.java&lt;/p&gt;

&lt;p&gt;public class Robot extends UntypedActor {
  private final String nombre;
  private ActorRef casillero;&lt;/p&gt;

&lt;p&gt;public Robot(String nombre) {
    this.nombre = nombre;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;public void onReceive(Object message) throws Exception {
    if (message instanceof MoveteEnDireccion) {
      MoveteEnDireccion moveteEnDireccion = (MoveteEnDireccion) message;
      nuevoCasillero((NuevoCasillero) casillero.ask(new MovemeA(moveteEnDireccion.getDireccion())).get());
    } else if (message instanceof DameTuNombre) {
      getContext().channel().tell(this.nombre);
    }else if (message instanceof NuevoCasillero) {
      nuevoCasillero((NuevoCasillero) message);
    } else {
      throw new IllegalArgumentException(&amp;ldquo;Unknown message: &amp;ldquo; + message);
    }
  }&lt;/p&gt;

&lt;p&gt;private  void nuevoCasillero(NuevoCasillero nuevoCasillero) {
    this.casillero = nuevoCasillero.getNuevoCasillero();
    }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
``` java Casillero.java

public class Casillero extends UntypedActor {
  private ActorRef robotEnCasillero;
  private Map&amp;lt;Direccion, ActorRef&amp;gt; casillerosVecinos;

  @Override
  public  void onReceive(Object message) throws Exception {
    if (message instanceof MovemeA) {
      movemeA((MovemeA) message);
    } else if (message instanceof RecibiRobot) {
      recibiRobot((RecibiRobot) message);
    } else if (message instanceof DameTuRobot) {
      dameTuRobot();
    } else if (message instanceof TusVecinosSon) {
      tusVecinosSon((TusVecinosSon) message);
    } else {
      throw new IllegalArgumentException(&amp;quot;Unknown message: &amp;quot; + message);
    }
  }

  private  void tusVecinosSon(TusVecinosSon tusVecinosSon) {
    this.casillerosVecinos = tusVecinosSon.getCasillerosVecinos();
  }

  private  void dameTuRobot() {
    getContext().reply(new MiRobot(this.robotEnCasillero));
  }

  private  void recibiRobot(RecibiRobot recibiRobot) {
    if (robotEnCasillero == null) {
      robotEnCasillero = recibiRobot.getRobot();
      getContext().channel().tell(new ResultadoMovimiento(true));
    } else {
      getContext().channel().tell(new ResultadoMovimiento(false));
    }
  }

  private  void movemeA(MovemeA movemeA) {
    Direccion haciaDonde = movemeA.getDireccion();
    ActorRef casilleroDestino = getCasilleroVecinoPorDireccion(haciaDonde);
    ActorRef nuevoCasillero = intentarMoverRobot(robotEnCasillero, casilleroDestino);
    getContext().reply(new NuevoCasillero(nuevoCasillero));
  }

  private ActorRef intentarMoverRobot(ActorRef robot, ActorRef casilleroDestino) {
    if (casilleroDestino == null) {
      return getContext();
    }
    ResultadoMovimiento resultadoMovimiento = (ResultadoMovimiento) casilleroDestino.ask(new RecibiRobot(robot))
            .get();
    if (resultadoMovimiento.fueExitoso()) {
      this.robotEnCasillero = null; // el robot ya no va mas aca
      return casilleroDestino;
    } else {
      return getContext();
    }
  }

  private ActorRef getCasilleroVecinoPorDireccion(Direccion haciaDonde) {
    return this.casillerosVecinos.get(haciaDonde);
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Las referencias entre actores no tipados en Akka se hacen mediante un ActorRef, que es un objeto que permite referenciar a un actor y comunicarnos con él. El objeto real es instanciado por Akka y no tenemos acceso directo a él. El mecanismo de ActorRef es serializable y hasta incluso puede enviarse serializadamente a otra JVM y esta puede utilizarla y enviar mensajes al Actor correcto.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;¿Como funciona esto? En primer lugar hay que tener en cuenta que cada actor solamente puede estar procesando un mensaje a la vez, y cuando inicia una comunicación sincronica, bloquea su procesamiento hasta que reciba la respuesta de la comunicación sincronica. Como solo el actor puede actualizar su propio estado, en cierta forma podemos pensar que este mecanismo funciona como un mecanismo de locking, ya que el casillero original no atenderá más mensajes hasta no recibir la respuesta del casillero vecino.&lt;/p&gt;

&lt;p&gt;Esta forma de resolverlo, de todas maneras, es insuficiente. En primer lugar, porque no es posible consultar una vista del tablero de forma consistente: La forma es preguntarle a los casilleros cuales son sus robots y obtener una vista consistente, ya que puede haber mensajes dando vueltas que estén actualizando el tablero, y podríamos sufrir el problema de tener robots duplicados o invisibles, como ya explicamos. En segundo lugar, &lt;strong&gt;teoricamente sería posible tener deadlocks&lt;/strong&gt;: si bien no lo reproduci, podría suceder que un robot quiera moverse a la derecha cuando a su derecha hay otro robot queriendo moverse a la izquierda. Si ambos casilleros enviaran un mensaje de recibi robot al mismo tiempo al otro lado, estarían bloqueandose mutuamente esperando la respuesta, hasta que ambos terminen con timeout. &lt;strong&gt;Esta es una de las razones por la cual hay que ser muy cuidadosos con la comunicación sincronica entre actores, y en general hay que preferir la asincronica.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Como dice la documentación de Akka, cuando hay que actualizar estado compartido entre actores de forma consistente, &lt;strong&gt;no es un problema fácil de resolver&lt;/strong&gt;. Akka ofrece un mecanismo que se llama Transactors que permitirían modificar el estado de varios actores al mismo tiempo. Dicho mecanismo se intentó implementar para este ejercicio, pero no había una forma de tomar decisiones en base al estado de uno de los actores (el casillero destino) cuando influyen en las decisiones del estado de otros actores (el robot y el casillero destino).
Otra solución posible dentro de Akka, es usar STM, y este es el segundo intento.&lt;/p&gt;

&lt;h2 id=&#34;segunda-implementación-actores-no-tipados-con-stm&#34;&gt;Segunda implementación, actores no tipados con STM&lt;/h2&gt;

&lt;p&gt;No debería sorprendernos que la forma ideal de lidiar con este problema sea utilizando STM, ya que este ejercicio está basado en un ejemplo de utilización de STM en Clojure. Con STM, lo que hacemos es utilizar una estructura de datos que gira en torno a variables transaccionales, y se consulta y se actualiza con transacciones.&lt;/p&gt;

&lt;p&gt;Lo que hacemos entonces es una clase Tablero que contiene una variable de tipo &lt;code&gt;Ref[][]&lt;/code&gt;: es decir, un array de dos dimensiones de tipo &lt;code&gt;Ref&lt;/code&gt;. &lt;code&gt;Ref&lt;/code&gt; es la variable transaccional de Akka, y es una variable que podemos consultar mediante get y set dentro de una transacción, y siempre tendremos una visión consistente de estas variables. Este array contendrá el nombre de cada robot, o null si no hubiera robot. Y existen dos transacciones que se aplicarán sobre este tablero: Una es mover un robot, dado una Posicion origen y una dirección, y la otra es obtener una vista del tablero, que en este caso es simplemente construir un String (hay una tercera para inicializar el tablero, pero solamente se utiliza a modo de set up).&lt;/p&gt;

&lt;p&gt;``` java Tablero.java&lt;/p&gt;

&lt;p&gt;public class Tablero {
  private Ref&lt;String&gt;[][] casilleros;
  private final  int xLength;
  private final  int yLength;&lt;/p&gt;

&lt;p&gt;public Tablero(int xLength, int yLength) {
    this.xLength = xLength;
    this.yLength = yLength;
    this.casilleros = new Ref[xLength][yLength];
    for(int i = 0; i &amp;lt; xLength; i++){
      for(int j = 0; j &amp;lt; yLength; j++){
        this.casilleros[i][j] = new Ref&lt;String&gt;();
      }&lt;br /&gt;
    }
  }
  public  void putRobotAt(final Posicion posicion, final String robotName){
    new Atomic&lt;Object&gt;(){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override
        public Object atomically() {
    casilleros[posicion.getX()][posicion.getY()].set(robotName);
    return null;
        }}.execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;public Posicion moveRobot(final Posicion posicionOrigen, final Direccion direccion) {
    return new Atomic&lt;Posicion&gt;() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override
  public Posicion atomically() {
    int x = posicionOrigen.getX();
    int y = posicionOrigen.getY();
    Ref&amp;lt;String&amp;gt; casilleroOrigen = casilleros[x][y];
    Posicion posicionDestino = null;
    switch (direccion) {
    case ABAJO:
      if (x + 1 &amp;lt; xLength) {
        posicionDestino = new Posicion(x + 1, y);
      }
      break;
    case ARRIBA:
      if (x - 1 &amp;gt;= 0) {
        posicionDestino = new Posicion(x - 1, y);
      }
      break;
    case DERECHA:
      if (y + 1 &amp;lt; yLength) {
        posicionDestino = new Posicion(x, y + 1);
      }
      break;
    case IZQUIERDA:
      if (y - 1 &amp;gt;= 0) {
        posicionDestino = new Posicion(x, y - 1);
      }
      break;
    }
    if (posicionDestino == null) {
      return posicionOrigen;
    }
    Ref&amp;lt;String&amp;gt; casilleroDestino = casilleros[posicionDestino.getX()][posicionDestino.getY()];
    if (casilleroDestino.get() != null) {
      return posicionOrigen;
    }
    casilleroDestino.set(casilleroOrigen.get());
    casilleroOrigen.set(null);
    return posicionDestino;
  }

}.execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;public String toString() {
    return new Atomic&lt;String&gt;() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Override
  public String atomically() {
    StringBuilder tablero = new StringBuilder();
    for (int i = 0; i &amp;lt; xLength; i++) {
      StringBuilder fila = new StringBuilder();
      for (int j = 0; j &amp;lt; yLength; j++) {
        String robotName = casilleros[i][j].get();
        if (robotName == null) {
          robotName = &amp;quot;#&amp;quot;;
        }
        fila.append(robotName);
      }
      tablero.append(fila);
      tablero.append(&amp;quot;\n&amp;quot;);
    }
    return tablero.toString();
  }
}.execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Este objeto es totalmente thread-safe, y como explica la documentación de Akka, al utilizar STM podemos compartir estado entre Actores, aunque obviamente, deben residir en la misma JVM.
Descartamos entonces el actor Casillero, y nos quedamos unicamente con el actor Robot, que se implementa simplemente así:

``` java Robot.java

public class Robot extends UntypedActor {
  private Posicion posicion;
  private final Tablero tablero;

  public Robot(Posicion posicion, Tablero tablero) {
    this.posicion = posicion;
    this.tablero = tablero;
  }

  public  void onReceive(final Object message) throws Exception {
    if (message instanceof MoveteEnDireccion) {
      MoveteEnDireccion moveteEnDireccion = (MoveteEnDireccion) message;
      this.posicion = this.tablero.moveRobot(this.posicion, moveteEnDireccion.getDireccion());
    } else {
      throw new IllegalArgumentException(&amp;quot;Unknown message: &amp;quot; + message);
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Todos los robots tienen una referencia al mismo tablero, y actualizan este estado utilizando transacciones. Luego, por afuera se consulta sobre el mismo objeto el método para obtener la vista. Esto resuelve efectivamente el problema planteado.&lt;/p&gt;

&lt;p&gt;¿Que más hay que tener en cuenta? Las transacciones modifican las mismas variables, entonces, ¿como hace Akka para resolver problemas de concurrencia? Utiliza &lt;strong&gt;multiversionado&lt;/strong&gt; de variables, donde existen varias versiones del estado de las variables, consultado de forma consistente, pero también detecta deadlocks y reinicia transacciones, puede reiniciarlas porque las transacciones deben ser totalmente libres de side effects (más allá de alterar las Ref, y las Ref solamente deben apuntar a objetos inmutables), como es el caso de las que implementamos aquí. Ahora bien, &lt;strong&gt;si subimos el numero de robots o el numero de movimientos iniciados, podemos llegar a ver que el programa deja de funcionar ya que las transacciones se reinician demasiadas veces&lt;/strong&gt;, hay que tener cuidado con esta posibilidad, y potencialmente configurar las transacciones de manera distinta.&lt;/p&gt;

&lt;h2 id=&#34;tercer-implementación-actores-tipados&#34;&gt;Tercer implementación, Actores tipados&lt;/h2&gt;

&lt;p&gt;Esta implementación es esencialmente identica a la de actores no tipados, la diferencia está en la forma de implementar los actores. Con actores no tipados, los actores implementan el método onReceive y reciben los mensajes como objetos, heredan de UntypedActor, y se referencia con ActorRef. Con actores tipados, los actores definen e implementan una interfaz donde cada método de la interfaz es un posible mensaje que puede recibir el objeto, heredan de TypedActor, y se referencian mediante la interfaz: Akka utiliza &lt;a href=&#34;http://en.wikipedia.org/wiki/Aspect-oriented_programming&#34;&gt;aspectos&lt;/a&gt; para generar un proxy al Actor, entonces invocar a un método del actor lo que hace es generar un mensaje asincrónico por detrás si el método es void, o sincrónico si el método devuelve un valor (hay una tercera opción que es devolver un Future).&lt;/p&gt;

&lt;p&gt;Así queda implementado el actor Robot utilizando actores tipados:&lt;/p&gt;

&lt;p&gt;``` java Robot.java&lt;/p&gt;

&lt;p&gt;public interface Robot {
  void moveteEnDireccion(Direccion direccion);
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
``` java RobotImpl.java

public class RobotImpl extends TypedActor implements Robot {
  private Posicion posicion;
  private final Tablero tablero;

  public RobotImpl(Posicion posicion, Tablero tablero) {
    this.posicion = posicion;
    this.tablero = tablero;
  }

  @Override
    public  void moveteEnDireccion(Direccion direccion) {
    this.posicion = this.tablero.moveRobot(this.posicion, direccion);
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¿Cual es la gran diferencia entre ambos esquemas? Actores tipados parece más fácil de utilizar, es cuestion de definir una interfaz y unos métodos, no hace falta crear clases para los mensajes, e invocar métodos de un Actor es muy similar a invocar métodos de un objeto. Pero los actores no tipados parecen ser más flexibles: Podemos consultar muchas más cosas sobre ellos, podemos hacer forwarding de mensajes de un actor a otro (pasar el mensaje a otro actor y que el actor destino responda directamente a quien envió el mensaje original), ya que el mensaje es un objeto, y más.&lt;/p&gt;

&lt;h2 id=&#34;cuarta-implementación-actores-remotos&#34;&gt;Cuarta implementación, Actores remotos&lt;/h2&gt;

&lt;p&gt;En esta implementación, quien muestra el estado del tablero es un proceso cliente, y quien tiene al tablero y a los actores Robot es un proceso servidor. Hay otro actor, muy simple llamado &lt;code&gt;VistaTablero&lt;/code&gt; con un método &lt;code&gt;getVista()&lt;/code&gt; que devuelve un &lt;code&gt;String[][]&lt;/code&gt; con el estado actual del tablero. Este actor se registra como un servicio con nombre &amp;ldquo;vista-tablero&amp;rdquo;, y se escucha en un puerto determinado, el cliente se conecta al servidor y obtiene una referencia a ese actor. Una vez obtenida la referencia, utilizar ese Actor es como si estuviera en la misma JVM. Esto es un mecanismo muy poderoso y fácil de utilizar.&lt;/p&gt;

&lt;p&gt;El servicio se registra en el servidor así:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
Actors.remote().start(&amp;quot;localhost&amp;quot;, 2552).registerTypedActor(&amp;quot;vista-tablero&amp;quot;, vistaTablero);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y se obtiene en el cliente de esta forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
VistaTablero vistaTablero = Actors.remote().typedActorFor(VistaTablero.class, &amp;quot;vista-tablero&amp;quot;, &amp;quot;localhost&amp;quot;, 2552);

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quinta-implementación-integración-con-spring-y-mecanismo-de-tolerancia-a-fallos&#34;&gt;Quinta implementación, integración con Spring y mecanismo de tolerancia a fallos&lt;/h2&gt;

&lt;p&gt;Akka tiene un módulo de integración con Spring que permite definir actores directamente en el contexto de Spring. El mecanismo funciona correctamente aunque es un poco complicado de utilizar, y cuesta un poco entender como se utilizan ciertos aspectos.&lt;/p&gt;

&lt;p&gt;En esta implementación además de configurar los actores en Spring, se implementó un mecanismo de tolerancia a fallos. La tolerancia a fallos en Akka se implementa mediante Supervisores que reinician los Actores cuando estos lanzen determinadas excepciones, restaurandolos a su estado correcto. La estrategia entonces es dejar fallar a los actores, y que los supervisores los reinicien. Existen varias estrategias de reinicio, en particular porque en algunos casos queremos que se reinicie solo el actor que falló y en otros queremos que se reinicie todo un grupo de actores que trabaja en conjunto.&lt;/p&gt;

&lt;p&gt;En este caso, implementamos un mecanismo de envio de mensajes de movimiento a los actores Robot dentro de un actor tipado que falla de manera aleatoria (esto en las implementaciones anteriores se hizo desde un thread aparte con un loop):&lt;/p&gt;

&lt;p&gt;``` java MotorMovimiento.java&lt;/p&gt;

&lt;p&gt;public interface MotorMovimiento {&lt;/p&gt;

&lt;p&gt;void moverRobots();&lt;/p&gt;

&lt;p&gt;void definirTablero(Tablero tablero);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
``` java MotorMovimientoImpl.java

public class MotorMovimientoImpl extends TypedActor implements MotorMovimiento {
  private Tablero tablero;

  @Override
  public  void moverRobots() {
    for (Robot robot : tablero.getRobots()) {
      robot.moveteEnDireccion(Direccion.direccionAtRandom());
    }
    try {
      Thread.sleep(Math.abs(new Random().nextInt()) % 500);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    if(Math.abs(new Random().nextInt()) % 15 == 0){
      throw new RuntimeException(&amp;quot;Excepcion aleatoria!&amp;quot;);
    }
    ((MotorMovimiento) this.context().getSelf()).moverRobots();
  }

  @Override
  public  void postRestart(Throwable reason) {
    selfSend();
  }
  
  private  void selfSend(){
    ((MotorMovimiento) this.context().getSelf()).moverRobots();
  }

  @Override
    public  void definirTablero(Tablero tablero) {
    this.tablero = tablero;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso, el actor se envia mensajes a si mismo para funcionar constantemente. Aleatoriamente lanza una RuntimeException, cuando esto sucede, el actor falla y se reinicia. En el reinicio (metodo post-restart) se colocó la condición de que el actor se vuelva a enviar a si mismo el mensaje original. Y se configuró via Spring el supervisor de este actor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;
&amp;lt;akka:supervision id=&amp;quot;motorMovimientoSupervisor&amp;quot;&amp;gt;
    &amp;lt;akka:restart-strategy failover=&amp;quot;AllForOne&amp;quot;
        retries=&amp;quot;10&amp;quot; timerange=&amp;quot;1000&amp;quot;&amp;gt;
        &amp;lt;akka:trap-exits&amp;gt;
            &amp;lt;akka:trap-exit&amp;gt;java.lang.Exception&amp;lt;/akka:trap-exit&amp;gt;
        &amp;lt;/akka:trap-exits&amp;gt;
    &amp;lt;/akka:restart-strategy&amp;gt;

    &amp;lt;akka:typed-actors&amp;gt;
        &amp;lt;akka:typed-actor id=&amp;quot;motorMovimiento&amp;quot;
            interface=&amp;quot;com.tenpines.prototypes.akka.movingrobots.actortyped.actores.MotorMovimiento&amp;quot;
            implementation=&amp;quot;com.tenpines.prototypes.akka.movingrobots.actortyped.actores.MotorMovimientoImpl&amp;quot;
            lifecycle=&amp;quot;permanent&amp;quot; timeout=&amp;quot;1000&amp;quot; depends-on=&amp;quot;tablero&amp;quot;&amp;gt;
        &amp;lt;/akka:typed-actor&amp;gt;
    &amp;lt;/akka:typed-actors&amp;gt;
&amp;lt;/akka:supervision&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lo que se configuró aquí es que se reinicie el actor, con un limite temporal de reintentos (no mas de 10 reintentos en 1000 milisegundos, para prevenir reintentar demasiado en situaciones donde los actores inmediatamente se caen), y ante cualquier excepción (mencionadas en la clausula trap-exit, en este caso aplican todas porque se especificó java.lang.Exception).&lt;/p&gt;

&lt;p&gt;Sexta implementación, integración con Apache Camel
Apache Camel es un framework de ruteo de mensajes que funciona con multiples protocolos como HTTP, JMS, SOAP, FTP, y muchisimos más, dentro de una única API basada en URIs. Akka está integrado con este framework permitiendo enviar y recibir mensajes de los actores por medio de estos protocolos, esta es una forma simple de utilizar Akka para interactuar con otros sistemas con protocolos como JMS o Webservices.&lt;/p&gt;

&lt;p&gt;En esta implementación, utilizamos un nuevo actor no tipado, VistaTableroJson, que implementa una vista JSON del tablero respondiendo cada mensaje con un String con el tablero serializado. Luego levantar el tablero en una dirección HTTP se realiza mediante la integración de Akka con Apache Camel y la integración de Apache Camel con Jetty (un servidor web liviano escrito en Java):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
final ActorRef vistaTableroJson = (ActorRef) context.getBean(&amp;quot;vistaTableroJson&amp;quot;);
CamelServiceManager.startCamelService();
CamelContextManager.mandatoryContext().addRoutes(new RouteBuilder(){

@Override
public void configure() throws Exception {
    from(&amp;quot;jetty:http://localhost:8080/tablero&amp;quot;).to(&amp;quot;actor:uuid:&amp;quot;+vistaTableroJson.getUuid() );
}});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Al entrar en la url jetty: &lt;code&gt;http://localhost:8080/tablero&lt;/code&gt;, se puede ver el estado del tablero representado como JSON.&lt;/p&gt;

&lt;h2 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h2&gt;

&lt;p&gt;Akka permite manejar la concurrencia de una forma distinta, es una herramienta que se puede tener en cuenta para resolver varios tipos de problemas, ya sea utilizando solamente STM, o también actores, actores remotos, la integración con Apache Camel, etc. Hay que tener en cuenta que estas implementaciones de ejemplo son ejemplos y habría que ver que clase de problemas podrían llegar a aparecer en un ambiente productivo. De todas maneras, en la página de Akka hay una &lt;a href=&#34;http://akka.io/docs/akka/1.1.1/additional/companies-using-akka.html&#34;&gt;lista de empresas utilizando Akka en producción&lt;/a&gt; como referencia de su uso productivo.&lt;/p&gt;

&lt;p&gt;Akka, en su proxima versión 2.0 que aún (a febrero 2012) no salió, promete mejorar incluso más las cosas. Se planea agregar mecanismos para load balancing automatico y manejo de la carga en clusters, incluyendo migraciones de actores de una maquina a otra de manera explicita o implicita. Y esto sería por medio de configuración, por lo que el mismo programa serviría para correr en una sola máquina o en varias según se necesite. También incluirá la posibilidad de que se utilice un sistema de eventos con suscriptores, permitiendo que los actores se comuniquen entre sí sin conocerse.&lt;/p&gt;

&lt;p&gt;El código fuente de las implementaciones está disponible &lt;a href=&#34;http://dl.dropbox.com/u/2520726/Akka-example-MovingRobots.zip&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>automatically change configuration based on current environment</title>
      <link>http://blog.10pines.com/2012/02/23/automatically-change-configuration-based-on-current-environment/</link>
      <pubDate>Thu, 23 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://blog.10pines.com/2012/02/23/automatically-change-configuration-based-on-current-environment/</guid>
      <description>&lt;p&gt;What if the application &lt;strong&gt;were aware&lt;/strong&gt; of its different running environments so it could change its configuration &lt;strong&gt;automatically&lt;/strong&gt; based on the current one?&lt;/p&gt;

&lt;p&gt;If we wanted to do that, we had to solve 2 issues:&lt;/p&gt;

&lt;p&gt;{% img &lt;a href=&#34;http://2.bp.blogspot.com/-eiWPoCGfqzQ/Tz7KWbP8pLI/AAAAAAAAAEM/XzBpA6-RV3Y/s1600/steps.png&#34;&gt;http://2.bp.blogspot.com/-eiWPoCGfqzQ/Tz7KWbP8pLI/AAAAAAAAAEM/XzBpA6-RV3Y/s1600/steps.png&lt;/a&gt; %}&lt;/p&gt;

&lt;p&gt;Fortunately &lt;strong&gt;for the second issue&lt;/strong&gt; we have &lt;em&gt;Spring 3.1&lt;/em&gt; which introduced the concept of profiles to bean definitions. This is similar to what maven does to files but applied to beans.&lt;/p&gt;

&lt;p&gt;Now, we can define different set of beans according to the current spring profile. If we structure our configuration in different sets of beans for each desired configuration we can change it easily.&lt;/p&gt;

&lt;p&gt;The problem remains in how to detect the current environment to tell which spring profile to use.
&lt;a href=&#34;http://goodenoughpractices.blogspot.com/2012/02/automatically-change-configuration.html&#34;&gt;(keep reading to know how&amp;hellip;)&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>protocolo fix: aspectos básicos y utilización en java mediante la librería quickfix/j</title>
      <link>http://blog.10pines.com/2011/11/21/protocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj/</link>
      <pubDate>Mon, 21 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>http://blog.10pines.com/2011/11/21/protocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj/</guid>
      <description>

&lt;h2 id=&#34;introducción&#34;&gt;Introducción&lt;/h2&gt;

&lt;p&gt;El protocolo **FIX ** (&lt;em&gt;Financial Information Exchange Protocol&lt;/em&gt;) es un protocolo de mensajes para el comercio de instrumentos financieros. &lt;strong&gt;FIX&lt;/strong&gt; se utiliza ampliamente para la comunicación automática entre los participantes del intercambio de instrumentos, y especifica como son los mensajes para crear ordenes de compra y venta y consultar cotizaciones de instrumento, entre otros. Este protocolo es el que hay que utilizar para comunicarnos con practicamente todos los mercados financieros de manera electrónica.&lt;/p&gt;

&lt;p&gt;En este articulo, veremos los aspectos básicos del protocolo &lt;strong&gt;FIX&lt;/strong&gt;, como utilizarlo mediante la librería de java &lt;strong&gt;QuickFIX/J&lt;/strong&gt; mediante un ejemplo como cliente y servidor, y algunos aspectos poco obvios que hay que tener en cuenta al utilizarlo.&lt;/p&gt;

&lt;h2 id=&#34;diferentes-versiones-del-protocolo-fix&#34;&gt;Diferentes versiones del protocolo FIX&lt;/h2&gt;

&lt;p&gt;El protocolo tiene diferentes versiones, el mismo fue evolucionando a través de los años, agregando diferentes mensajes y campos para acomodar las funcionalidades requeridas por los interlocutores de todo el mundo. La versión del protocolo se divide en dos: la versión del protocolo de mensajes en si (por ejemplo, &lt;strong&gt;FIX 5.0 SP2&lt;/strong&gt;), y la versión del protocolo de transporte de &lt;strong&gt;FIX&lt;/strong&gt;, &lt;strong&gt;FIXT&lt;/strong&gt; (por ejemplo, &lt;strong&gt;FIXT 1.1&lt;/strong&gt;). Las versiones anteriores a la 5 no tenían esa division de protocolo de mensajes y protocolo de transporte, y se denotan únicamente por el número de version del protocolo.&lt;/p&gt;

&lt;p&gt;El protocolo &lt;strong&gt;FIX&lt;/strong&gt; soporta extensiones, agregando nuevos mensajes y campos dentro de mensajes existentes, definiendo nuevos códigos de mensaje y nuevos números de campos. Para esto, los interlocutores deben conocer y estar de acuerdo en estas extensiones. De todas maneras, el protocolo &lt;strong&gt;FIX&lt;/strong&gt; tiene una gran cantidad de campos pensados para muchisimos casos de usos, ampliandose versión a versión, por lo que la necesidad de extender el protocolo debería en teoría ser muy baja. Tampoco es necesario implementar la totalidad de los mensajes y todos los códigos opcionales existentes, sino solo los que tengan sentido y sean utilizados por nuestros interlocutores.&lt;/p&gt;

&lt;h2 id=&#34;cómo-es-el-formato-fix&#34;&gt;Cómo es el formato FIX&lt;/h2&gt;

&lt;p&gt;El formato &lt;strong&gt;FIX&lt;/strong&gt; es un formato textual, donde cada mensaje es una única linea de la forma:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NUMERO_DE_CAMPO=CONTENIDO[SEPARADOR]NUMERO_DE_CAMPO=CONTENIDO[SEPARADOR]....&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;El separador es el caracter unicode representado en Java y otros como &lt;strong&gt;&amp;ldquo;\u0001&amp;rdquo;&lt;/strong&gt;. Los campos se identifican por su número, y el tipo de mensaje es un campo más dentro del mensaje (el campo 35), y el último campo es el campo 10 que es el checksum. El orden de los campos importa, y está especificado para cada mensaje &lt;strong&gt;FIX&lt;/strong&gt;. Las estructuras repetitivas en &lt;strong&gt;FIX&lt;/strong&gt; se llaman &lt;strong&gt;Repeating Group&lt;/strong&gt; y se definen simplemente definiendo un campo cabecera del &lt;strong&gt;Repeating Group&lt;/strong&gt; que indica la cantidad de elementos contenidos, y todos los elementos se diferencian entre sí detectando el primer campo de cada elemento, esto funciona precisamente porque importa el orden de los campos.&lt;/p&gt;

&lt;h2 id=&#34;quickfix-j&#34;&gt;QuickFIX/J&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;FIX&lt;/strong&gt; es un protocolo abierto y gratuito; es solo la especificación de los mensajes y de los campos de los mismos, y existen varias implementaciones de este protocolo. &lt;strong&gt;QuickFIX/J&lt;/strong&gt; es una implementación gratuita y open source (con una licencia propia similar a &lt;strong&gt;BSD&lt;/strong&gt;/&lt;strong&gt;MIT&lt;/strong&gt;) para Java (es un port de &lt;strong&gt;QuickFIX&lt;/strong&gt;, que está escrita en C++), que es muy fácil de utilizar para comunicarnos con cualquier participante, ya sea como cliente o servidor.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nota: QuickFIX/J no implementa lógica de negocio alguna, es decir, no implementa ningún motor de cotizaciones, matcheo de ordenes de compra y venta, etc; lo que implementa es únicamente es el protocolo de comunicación.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;ejemplos-de-cliente-y-servidor-en-quickfix-j&#34;&gt;Ejemplos de Cliente y Servidor en QuickFIX/J&lt;/h2&gt;

&lt;p&gt;Vamos a hacer un cliente de ejemplo en &lt;strong&gt;QuickFIX/J&lt;/strong&gt; versión 1.5.1. Este cliente se conectará a un servidor, y apenas se conecte enviará una orden de compra de un instrumento ficticio, el servidor responderá con otro mensaje, y cuando el cliente reciba la respuesta de la compra, seteará una variable, y observaremos la respuesta de esa variable. Con este ejemplo, si bien irreal, veremos como se utiliza &lt;strong&gt;QuickFIX/J&lt;/strong&gt; como cliente y como servidor.&lt;/p&gt;

&lt;p&gt;El primer paso es &lt;a href=&#34;http://www.quickfixj.org/downloads/&#34;&gt;bajar la librería&lt;/a&gt;. Hay varios Jars, uno por cada versión del protocolo &lt;strong&gt;FIX&lt;/strong&gt;, pero vamos a incluir simplemente el que tiene todo (&amp;ldquo;all&amp;rdquo;), en este caso voy a incluir la última versión: &lt;strong&gt;quickfixj-all-1.5.1.jar&lt;/strong&gt;. También debemos bajar (o bien configurar via Maven) las dependencias especificadas &lt;a href=&#34;http://www.quickfixj.org/quickfixj/usermanual/1.5.1/installation.html#dependencies&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Incluida esta librería en nuestro proyecto, tenemos que implementar nuestro cliente, y para esto &lt;strong&gt;QuickFIX/J&lt;/strong&gt; nos pide que implementemos la interfaz &lt;code&gt;quickfix.Application&lt;/code&gt;. &lt;strong&gt;QuickFIX/J&lt;/strong&gt; es un framework que trabaja con el concepto de &lt;em&gt;Inversión de Control&lt;/em&gt;: en lugar de invocar los métodos de &lt;strong&gt;QuickFIX/J&lt;/strong&gt; para loguearnos, ir recibiendo los mensajes, etc; nosotros tenemos que darle un objeto &lt;code&gt;Application&lt;/code&gt; y &lt;strong&gt;QuickFIX/J&lt;/strong&gt; invoca a los métodos de ese objeto con los eventos que vayan ocurriendo, en sus propios threads.&lt;/p&gt;

&lt;p&gt;La interfaz &lt;code&gt;Application&lt;/code&gt; define métodos para cada evento que ocurra durante la comunicación, por ejemplo &lt;code&gt;onLogon&lt;/code&gt;, &lt;code&gt;onLogout&lt;/code&gt;, &lt;code&gt;fromApp&lt;/code&gt; (se recibió un mensaje de negocio), &lt;code&gt;fromAdmin&lt;/code&gt; (se recibio un mensaje relativo a la sesión, como por ejemplo rechazo de un mensaje mal formado), entre otros. Nosotros, en vez de implementar &lt;code&gt;Application&lt;/code&gt; directamente, vamos a heredar de &lt;code&gt;ApplicationAdapter&lt;/code&gt; que es una clase abstracta que tiene definiciones vacías para todos estos métodos por default. Es la misma interfaz tanto para Cliente como para Servidor.&lt;/p&gt;

&lt;p&gt;``` java ExampleClientApplication.java&lt;/p&gt;

&lt;p&gt;package com.tenpines.ejemplofix;&lt;/p&gt;

&lt;p&gt;import quickfix.ApplicationAdapter;
import quickfix.FieldNotFound;
import quickfix.Message;
import quickfix.Session;
import quickfix.SessionID;
import quickfix.SessionNotFound;
import quickfix.field.ExecType;
import quickfix.field.Password;
import quickfix.field.Username;
import quickfix.fix50.ExecutionReport;
import quickfix.fix50.NewOrderSingle;
import quickfix.fixt11.Logon;&lt;/p&gt;

&lt;p&gt;public class ExampleClientApplication extends ApplicationAdapter {
  private boolean seEjecutoOrdenCorrectamente = false;
  private  boolean estaLogueado = false;&lt;/p&gt;

&lt;p&gt;private final NewOrderSingle newOrder;
  private final String usuario;
  private final String password;&lt;/p&gt;

&lt;p&gt;public ExampleClientApplication(NewOrderSingle newOrder, String usuario, String password) {
    this.newOrder = newOrder;
    this.usuario = usuario;
    this.password = password;
  }&lt;/p&gt;

&lt;p&gt;@Override
  public  void onLogon(SessionID sessionId) {
    this.estaLogueado = true;
    try {
      Session.sendToTarget(this.newOrder, sessionId);
    } catch (SessionNotFound e) {
      throw new RuntimeException(e);
    }
  }&lt;/p&gt;

&lt;p&gt;@Override
  public  void fromApp(Message message, SessionID sessionId) throws FieldNotFound {
    if (message instanceof ExecutionReport) {
      ExecutionReport executionReport = (ExecutionReport) message;
      if (esExecutionReportNew(executionReport)) {
        // Como el mensaje corresponde a una creacion de orden,
        // verifico que se refiera a la misma orden que acabo de enviar
        // comparando su ClOrdID.
        if (esClOrdIDCorrecto(executionReport)) {
          this.seEjecutoOrdenCorrectamente = true;
        }
      }
    }
  }&lt;/p&gt;

&lt;p&gt;private  boolean esClOrdIDCorrecto(ExecutionReport executionReport) throws FieldNotFound {
    return executionReport.getClOrdID().getValue().equals(this.newOrder.getClOrdID().getValue());
  }&lt;/p&gt;

&lt;p&gt;private  boolean esExecutionReportNew(ExecutionReport executionReport) throws FieldNotFound {
    return executionReport.getExecType().getValue() == ExecType.NEW;
  }&lt;/p&gt;

&lt;p&gt;@Override
  public  void toAdmin(Message message, SessionID sessionId) {
    if (message instanceof Logon) {
      message.setField(new Username(usuario));
      message.setField(new Password(password));
    }
  }&lt;/p&gt;

&lt;p&gt;public  boolean estaLogueado() {
    return estaLogueado;
  }&lt;/p&gt;

&lt;p&gt;public  boolean seEjecutoOrdenCorrectamente() {
    return seEjecutoOrdenCorrectamente;
  }
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Esta clase en su constructor recibirá el mensaje `NewOrderSingle` de creación de una orden, que el cliente deberá enviar al loguearse. En el método `onLogon`, el cual **QuickFIX/J** invoca luego de un logueo exitoso, realiza el envío del mensaje con el método estático `Session.sendToTarget`.

En el método `fromApp`, se reciben los mensajes de negocio, y lo que buscamos es un mensaje de `ExecutionReport`, que es el mensaje de **FIX** con el que se reportan los cambios de estado de una orden (cuando es creada, cuando es cancelada, a medida que se va ejecutando, cuando es completada, etc).

Si el campo `ClOrdID` (el cual representa el *id de orden del cliente*) del `ExecutionReport` coincide con el que mandamos en el `NewOrderSingle`, seteamos el flag de `seEjecutoOrdenCorrectamente`.

Finalmente en el método `toAdmin`, que se invoca inmediatamente antes de enviar un mensaje &amp;quot;administrativo&amp;quot; (es decir, un mensaje que no es de negocio), interceptamos el mensaje `Logon` (que se crea automáticamente) y le asignamos usuario y password (sí, esa es la forma estándar de definir el usuario y password de la conexión).

``` java ExampleServerApplication.java

package com.tenpines.ejemplofix;

import quickfix.ApplicationAdapter;
import quickfix.FieldNotFound;
import quickfix.IncorrectTagValue;
import quickfix.Message;
import quickfix.RejectLogon;
import quickfix.Session;
import quickfix.SessionID;
import quickfix.SessionNotFound;
import quickfix.UnsupportedMessageType;
import quickfix.field.ClOrdID;
import quickfix.field.CumQty;
import quickfix.field.ExecID;
import quickfix.field.ExecType;
import quickfix.field.LeavesQty;
import quickfix.field.OrdStatus;
import quickfix.field.OrderID;
import quickfix.fix50.ExecutionReport;
import quickfix.fix50.NewOrderSingle;
import quickfix.fixt11.Logon;

public class ExampleServerApplication extends ApplicationAdapter {

  @Override
  public  void fromAdmin(Message message, SessionID sessionId) throws FieldNotFound, RejectLogon {
    if (message instanceof Logon) {
      if (!usuarioYPasswordCorrectos((Logon) message)) {
        throw new RejectLogon();
      }
    }
  }

  private  boolean usuarioYPasswordCorrectos(Logon logon) throws FieldNotFound {
    return logon.getUsername().getValue().equals(&amp;quot;usuario&amp;quot;) 
        &amp;amp;&amp;amp; logon.getPassword().getValue().equals(&amp;quot;password&amp;quot;);
  }

  @Override
  public  void fromApp(Message message, SessionID sessionId) throws FieldNotFound, IncorrectTagValue,
          UnsupportedMessageType {
    if (message instanceof NewOrderSingle) {
      NewOrderSingle newOrderSingle = ((NewOrderSingle) message);
      ExecutionReport executionReport = new ExecutionReport();
      String clOrdID = newOrderSingle.getClOrdID().getValue();
      executionReport.set(new ClOrdID(clOrdID));
      executionReport.set(new ExecID(&amp;quot;98765&amp;quot;));
      executionReport.set(new OrderID(&amp;quot;99999&amp;quot;));
      executionReport.set(newOrderSingle.getSide());
      executionReport.set(new OrdStatus(OrdStatus.NEW));
      executionReport.set(new CumQty(0));
      executionReport.set(new ExecType(ExecType.NEW));
      executionReport.set(new LeavesQty(newOrderSingle.getOrderQty().getValue()));
      try {
        Session.sendToTarget(executionReport, sessionId);
      } catch (SessionNotFound e) {
        throw new RuntimeException(e);
      }
    }
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este es el &lt;code&gt;Application&lt;/code&gt; del servidor de ejemplo. En el método &lt;code&gt;fromAdmin&lt;/code&gt; (donde se reciben los mensajes administrativos), validamos el &lt;code&gt;Login&lt;/code&gt;, si no coincide el usuario y password, lanzamos la excepcion &lt;code&gt;RejectLogin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota:&lt;/strong&gt; en este esquema sencillo, el password viaja como texto plano: Las conexiones de FIX tienen que segurizarse por medio de algún esquema como SSL, utilizar una VPN, o similar.&lt;/p&gt;

&lt;p&gt;En el metodo &lt;code&gt;fromApp&lt;/code&gt; recibimos el &lt;code&gt;NewOrderSingle&lt;/code&gt; y creamos un mensaje de &lt;code&gt;ExecutionReport&lt;/code&gt; y le asignamos varios campos (en este ejemplo, solo los obligatorios). En el campo &lt;code&gt;ClOrdID&lt;/code&gt;, copiamos el dato recibido por el &lt;code&gt;NewOrderSingle&lt;/code&gt;, para que el cliente pueda detectar a que &lt;code&gt;ExecutionReport&lt;/code&gt; corresponde. Y finalmente enviamos el mensaje.&lt;/p&gt;

&lt;p&gt;``` java ExampleFixTest.java&lt;/p&gt;

&lt;p&gt;package com.tenpines.ejemplofix;&lt;/p&gt;

&lt;p&gt;import java.util.Date;&lt;/p&gt;

&lt;p&gt;import org.junit.Assert;
import org.junit.Test;&lt;/p&gt;

&lt;p&gt;import com.tenpines.ejemplofix.ExampleClientApplication;
import com.tenpines.ejemplofix.ExampleServerApplication;&lt;/p&gt;

&lt;p&gt;import quickfix.Application;
import quickfix.ConfigError;
import quickfix.DefaultMessageFactory;
import quickfix.MemoryStoreFactory;
import quickfix.ScreenLogFactory;
import quickfix.SessionSettings;
import quickfix.SocketAcceptor;
import quickfix.SocketInitiator;
import quickfix.field.ClOrdID;
import quickfix.field.OrdType;
import quickfix.field.OrderQty;
import quickfix.field.Side;
import quickfix.field.TransactTime;
import quickfix.fix50.NewOrderSingle;&lt;/p&gt;

&lt;p&gt;public class ExampleFixTest {&lt;/p&gt;

&lt;p&gt;@Test
  public  void test() throws Exception {
    iniciarServidor();
    String password = &amp;ldquo;password&amp;rdquo;;
    String usuario = &amp;ldquo;usuario&amp;rdquo;;
    NewOrderSingle newOrder = new NewOrderSingle(new ClOrdID(&amp;ldquo;12345&amp;rdquo;), new Side(Side.BUY),
        new TransactTime(new Date()), new OrdType(OrdType.MARKET));
    newOrder.set(new OrderQty(1000));
    ExampleClientApplication application = new ExampleClientApplication(newOrder, usuario, password);
    iniciarCliente(application);
    Thread.sleep(5000L); // 5 segundos
    Assert.assertTrue(application.estaLogueado());
    Assert.assertTrue(application.seEjecutoOrdenCorrectamente());
  }&lt;/p&gt;

&lt;p&gt;private  void iniciarCliente(Application application) throws ConfigError {
    SessionSettings settings = new SessionSettings(this.getClass().getResourceAsStream(&amp;ldquo;cliente.cfg&amp;rdquo;));
    SocketInitiator socketInitiator = new SocketInitiator(application, new MemoryStoreFactory(), settings,
            new ScreenLogFactory(), new DefaultMessageFactory());
    socketInitiator.start();
  }&lt;/p&gt;

&lt;p&gt;private  void iniciarServidor() throws ConfigError {
    SessionSettings settings = new SessionSettings(this.getClass().getResourceAsStream(&amp;ldquo;servidor.cfg&amp;rdquo;));
    ExampleServerApplication application = new ExampleServerApplication();
    SocketAcceptor acceptor = new SocketAcceptor(application, new MemoryStoreFactory(), settings,
            new ScreenLogFactory(), new DefaultMessageFactory());
    acceptor.start();
  }
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
En este test inicializamos el cliente y el servidor, y vemos que efectivamente el cliente se loguea contra el servidor, envia la orden, y recibe la respuesta. Notese que el cliente y el servidor se construyen de maneras distintas pero similares: el primero con un `SocketIniciator` y el segundo con un `SocketAcceptor`. En el constructor de cada uno de ellos se pasan objetos que permiten parametrizar el comportamiento del motor de **QuickFIX/J**, definiendo el esquema de logging, como se guardan los mensajes, y cual es el Factory de los mensajes (que depende de la versión del protocolo de **FIX**, pero `DefaultMessageFactory` sirve para cualquier versión).

Hay que tener cuidado al hacer tests integrales con **QuickFIX/J**, ya que como el `Application` corre en un thread aparte, instanciado por **QuickFIX/J**, perdemos el control de la ejecución y necesitamos algún tipo de espera o sincronismo para asegurarnos de que cumplieron las acciones deseadas (en este caso, que se loguee el cliente contra el servidor y se envien entre ellos los mensajes `NewOrderSingle` y `ExecutionReport`). Por esto hay en el test un `Thread.sleep` con 5 segundos, si este fuera un test real, lo correcto sería utilizar polling con timeout, no `Thread.sleep` ya que es un método obviamente lento.

``` linux-config cliente.cfg

[default]
ConnectionType=initiator
StartTime=00:00:00
EndTime=00:00:00
HeartBtInt=300

[session]
BeginString=FIXT.1.1
DefaultApplVerID=FIX.5.0
SocketConnectHost=localhost
SocketConnectPort=9876
SenderCompID=CLIENTE
TargetCompID=SERVIDOR

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;``` linux-config servidor.cfg&lt;/p&gt;

&lt;p&gt;[default]
ConnectionType=acceptor&lt;/p&gt;

&lt;p&gt;StartTime=00:00:00
EndTime=00:00:00&lt;/p&gt;

&lt;p&gt;HeartBtInt=300
RejectInvalidMessage=N&lt;/p&gt;

&lt;p&gt;[session]
BeginString=FIXT.1.1
DefaultApplVerID=FIX.5.0
SocketAcceptPort=9876
SenderCompID=SERVIDOR
TargetCompID=CLIENTE&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
`ConnectionType` identifica el tipo de conexión, es decir, si es servidor o cliente. `StartTime` y `EndTime` indican el inicio y fin de la sesión y está relacionado al tiempo de apertura y cierre de los mercados. `BeginString` indica la versión del protocolo de transporte de **FIX**, y `DefaultApplVerID` indica la versión del protocolo (las versiones anterior a la 5, no tienen un protocolo de transporte especifico diferenciado de la versión de **FIX** en sí, y se definen únicamente por el `BeginString` indicando el protocolo de **FIX**).

`SenderCompID` y `TargetCompID` son identificadores de los interlocutores de la sesión, y están invertidos en el Cliente y el Servidor. En **FIX**, la sesión es algo que se considera que va más allá de la conexión dada en un momento, si la conexión se cae y después se vuelve a conectar, la sesión sigue siendo la misma, y de hecho se reenvían los mensajes pendientes al momento de caerse la sesión (en **QuickFIX/J** para que esto funcione hay que instanciar el `SocketAcceptor/Initiator` con el `FileStoreFactory`, no el `MemoryStoreFactory`, el cual guarda los mensajes en un archivo para poder reenviarlos). Justamente porque la sesión es algo global, el `SessionID` de **QuickFIX/J** está definido básicamente por tres valores: `SenderCompID`, `TargetCompID` y `BeginString`.

## Cuestiones a considerar de QuickFIX/J

**QuickFIX/J** utiliza &amp;quot;diccionarios&amp;quot; que definen los mensajes de **FIX**:

- Los tipos de mensajes y su código identificatorio
- Los campos que contiene cada mensaje, su tipo, valores válidos
- Los repeating groups (cual es el encabezado del grupo y los campos de los elementos del repeating group)

Cada diccionario es un XML que se puede editar. Si abrimos los fuentes de **QuickFIX/J** veremos que tiene un diccionario de datos por cada versión del protocolo **FIX**, y utiliza generación de código en el build para crear todas las clases que representan cada mensaje y cada campo (ya que en **QuickFIX/J**, cada campo es una clase). Si queremos, podemos modificar este XML y configurar **QuickFIX/J** para que utilice nuestro XML, esto es necesario si utilizamos extensiones del protocolo que agreguen nuevos campos.

Justamente por ser estas clases autogeneradas, tienen ciertos aspectos contra-intutivos:

Cada campo está representado por una clase. El campo `OrderQty`, que representa la cantidad a comerciar en una órden y es un número, por ejemplo, está representado por la clase `OrderQty`, y una instancia de `OrderQty` tiene métodos como `getValue` para obtener el valor del campo y `getField` para obtener el número de campo en el protocolo.

En las clases que representan los mensajes, no existen métodos `setCAMPO(tipoDeDato)`, sino unicamente overloads del metodo set que reciben la clase que representa el tipo de dato. Por eso, para setear por ejemplo el campo `OrderQty`, hay que hacer cosas como `newOrder.set(new OrderQty(1000))`. Y los métodos get, si bien están definidos, devuelven el valor envuelto en la clase que representa su campo.

Los **Repeating Groups** también están representados por una clase, y la clase se llama igual que el campo del encabezado. Por ejemplo, en el mensaje `SecurityList`, que contiene una lista de instrumentos financieros, hay un repeating group de instrumentos, y para extraerlos, hay que hacer lo siguiente:

``` java

quickfix.fix50.SecurityList.NoRelatedSym noRelatedSym = new quickfix.fix50.SecurityList.NoRelatedSym();
message.getGroup(indiceDeGrupo + 1, noRelatedSym); // +1 porque el primer grupo tiene indice 1, no 0.
//ahora noRelatedSym tiene los datos del grupo

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esto es confuso porque &lt;code&gt;NoRelatedSym&lt;/code&gt; es en realidad el nombre del campo que tiene la cantidad de simbolos relacionados (&amp;ldquo;No&amp;rdquo; en &amp;ldquo;NoRelatedSym&amp;rdquo; es una abreviación de &amp;ldquo;número&amp;rdquo;), y no del &lt;strong&gt;Repeating Group&lt;/strong&gt; en sí, esto es una consecuencia de la generación de código automática de &lt;strong&gt;QuickFix/J&lt;/strong&gt;. Para añadir confusión, hay multiples clases llamadas &lt;code&gt;NoRelatedSym&lt;/code&gt;, cada una de ellas representando un &lt;strong&gt;Repeating Group&lt;/strong&gt; distinto dentro de cada mensaje. Por eso estas clases son internas al mensaje (como se puede ver en el ejemplo, esta clase &lt;code&gt;NoRelatedSym&lt;/code&gt; es interna a la clase &lt;code&gt;SecurityList&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;recursos-útiles&#34;&gt;Recursos útiles&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fixprotocol.org:&#34;&gt;http://www.fixprotocol.org:&lt;/a&gt; Donde se puede conseguir la especificación del protocolo en todas sus versiones. Dentro de este sitio se encuentra &lt;a href=&#34;http://www.fixprotocol.org/FIXimate3.0/&#34;&gt;FIXimate&lt;/a&gt;, herramienta que permite consultar mensajes o campos por su código, esencial para entender mensajes de errores y logs de mensajes.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quickfixj.org/:&#34;&gt;http://www.quickfixj.org/:&lt;/a&gt; Sitio web de QuickFIX/J, con la documentación de la librería.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>